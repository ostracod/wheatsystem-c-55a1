
INCLUDE "../macros.wbasm"

MACRO callCheckPerm, window
    newArgFrame checkPerm.argsSize
    caller checkPerm.args.app
    wrt checkPerm.args.window, window
    call checkPerm
END

MACRO callCreateLine, dest, lineIndex, lines, lineCount
    newArgFrame createLine.argsSize
    wrt createLine.args.lines, lines
    wrt createLine.args.lineCount, lineCount
    call createLine
    wrt dest, createLine.args.dest
    wrt lines, createLine.args.lines
    wrt lineCount, createLine.args.lineCount
    wrt lineIndex, 0
END

# Sets the correct value for `cursorPosY` in `promptWindowText`.
MACRO updateCursorPosY
    div cursorPosY, cursorIndex, termWidth
    add cursorPosY, prevArg, messageLineAmount
    sub cursorPosY, prevArg, verticalScroll
END

# Mode of window operation is stored at `mode_OFFSET` in each window.

DEF none_MODE, 0
DEF displayMessage_MODE, 1
DEF promptOption_MODE, 2
DEF promptText_MODE, 3

# Lifecycle state of clean up is stored at `cleanUpState_OFFSET` in each window.

# Window should not be deleted.
DEF none_CLEAN_UP_STATE, 0
# Window mode should enter `none_MODE` in preparation for deletion.
DEF prepare_CLEAN_UP_STATE, 1
# Window should be deleted in `runShellMenu`.
DEF delete_CLEAN_UP_STATE, 2

# The offset of each field within a window allocation is defined below.

# The file handle of the app which owns the window.
DEF owner_OFFSET, 0
DEF cleanUpState_OFFSET, 4
DEF title_OFFSET, 5
DEF mode_OFFSET, 9
# Pointer to allocation containing characters to display.
DEF termBuff_OFFSET, 10
DEF verticalScroll_OFFSET, 14
DEF messageLines_OFFSET, 16
DEF messageLineAmount_OFFSET, 20
# In `promptWindowOption`, stores a pointer to an array of option pointers.
# In `promptWindowText`, stores a pointer to a text allocation.
DEF input_OFFSET, 22
# In `promptWindowOption`, stores the number of options from which to select.
# In `promptWindowText`, stores the number of characters provided by the user.
DEF inputLen_OFFSET, 26
# Stores horizontal scroll of the current option in `promptWindowOption`.
DEF inputHorizontalScroll_OFFSET, 28
DEF inputCursorIndex_OFFSET, 30
# Stores the key which has just been pressed.
DEF key_OFFSET, 32
# Communicates from `termInput` to `waitForKey` when a key is ready to be registered.
DEF keyGate_OFFSET, 33
# Communicates from `waitForKey` to `termInput` when the key has been registered.
# Also notifies `delWindow` when the window mode might be `none_MODE`.
DEF ackGate_OFFSET, 37
# Index of `reqDelWindow` function in the owner app.
DEF reqDelIndex_OFFSET, 41
# Index of `windowKeyPressed` function in the owner app.
DEF keyPressedIndex_OFFSET, 45
# Index of `windowFocusChanged` function in the owner app.,
DEF focusChangedIndex_OFFSET, 49
# Total size of each window allocation.
DEF window_SIZE, 53

VAR thisApp, s32
# Must be acquired when accessing `windows`, `windowCount`, or `focusedWindow`.
VAR windowsMutex, s32
# Pointer to array of pointer to all window allocations.
VAR windows, s32
# The total number of windows.
VAR windowCount, s8
# The window which is currently visible to the user.
VAR focusedWindow, s32
# The window which is focused when the user presses the system menu button.
VAR shellWindow, s32
# File handle to the file manager app.
VAR fileManagerHandle, s32
# Notifies `runShellMenu` when the shell window has gained focus.
VAR mainMenuGate, s32
# Notifies `runShellMenu` when a window has been deleted.
VAR delWindowGate, s32
# Prevents `termInput` from trying to access a window which is being deleted.
VAR cleanUpGate, s32

# File handle to the terminal driver app.
VAR termHandle, s32
# Index of `wrtTerm` function in the terminal driver.
VAR wrtTermIndex, s32
VAR termWidth, s16
VAR termHeight, s16
# Total number of characters which the terminal can display.
VAR termBuffSize, s32
VAR emptyLine, s32

FUNC init, wsInit.id, guarded
    
    # Initialize various global variables.
    thisApp thisApp
    newGate windowsMutex, 1
    newGate mainMenuGate, 1
    closeGate mainMenuGate
    newGate delWindowGate, 1
    closeGate delWindowGate
    newGate cleanUpGate, 1
    newAlloc windows, guardedAllocAttr, 20
    wrt windowCount, 0
    
    # Launch terminal driver and determine terminal size.
    VAR termName, s32
    newTextAlloc termName, termNameStart, termNameEnd
    openFile termHandle, termName
    delAlloc termName
    launch termHandle
    findFunc wrtTermIndex, termHandle, wsWrtTerm.id
    VAR funcIndex, s32
    findFunc funcIndex, termHandle, wsTermSize.id
    newArgFrame wsTermSize.argsSize
    callRemote termHandle, funcIndex
    wrt termWidth, wsTermSize.args.widthDest
    wrt termHeight, wsTermSize.args.heightDest
    mul termBuffSize, termWidth, termHeight
    
    # Create empty text line allocation.
    newAlloc emptyLine, guardedAllocAttr, termWidth
    fillBuff emptyLine[0]:s8, termWidth, 32:s8
    
    # Become an observer of the terminal driver.
    findFunc funcIndex, termHandle, wsListenTerm.id
    callRemote termHandle, funcIndex
    
    # Launch an example application which interacts with the shell.
    VAR dummyName, s32
    VAR dummyHandle, s32
    newTextAlloc dummyName, dummyNameStart, dummyNameEnd
    openFile dummyHandle, dummyName
    delAlloc dummyName
    launch dummyHandle
    closeFile dummyHandle
    
    # Create the shell window, and run the main loop for the shell.
    newArgFrame newWindow.argsSize
    call newWindow
    wrt shellWindow, newWindow.args.dest
    call runShellMenu
END

FUNC termInput, wsTermInput.id, guarded
    ARG key, s8
    
    # If the system menu button is pressed, focus the shell window.
    jmpNE skipSystemMenu, key, -6
    newArgFrame focusWindow.argsSize
    wrt focusWindow.args.window, shellWindow
    call focusWindow
    ret
    LBL skipSystemMenu
    
    # Branch based on focused window mode.
    waitGate cleanUpGate
    VAR window, s32
    wrt window, focusedWindow
    jmpNE openKeyGate, window[mode_OFFSET]:s8, none_MODE
    
    # If mode is `none_MODE`, call `windowKeyPressed` on owner app.
    VAR keyPressedIndex, s32
    wrt keyPressedIndex, window[keyPressedIndex_OFFSET]:s32
    jmpG finishHandle, 0, keyPressedIndex
    newArgFrame wsWindowKeyPressed.argsSize
    wrt wsWindowKeyPressed.args.window, window
    wrt wsWindowKeyPressed.args.key, key
    setErrJmp handleErr
    callRemote window[owner_OFFSET]:s32, keyPressedIndex
    LBL handleErr
    clrErrJmp
    jmp finishHandle
    
    # Communicate key when window mode is not `none_MODE`.
    LBL openKeyGate
    VAR keyGate, s32
    wrt keyGate, window[keyGate_OFFSET]:s32
    openGate keyGate
    waitGate window[ackGate_OFFSET]:s32
    wrt window[key_OFFSET]:s8, key
    LBL resetLoop
    jmpE breakReset, window[mode_OFFSET]:s8, none_MODE
    jmpNZ resetLoop, window[key_OFFSET]:s8
    LBL breakReset
    closeGate keyGate
    
    LBL finishHandle
    openGate cleanUpGate
END

FUNC checkPerm, 0, guarded
    ARG app, s32
    ARG window, s32
    
    # Throw `permErr` if `app` does not own the window, is not
    # the shell app, and does not hold admin permission.
    VAR cond, s8
    jmpE return, app, window[owner_OFFSET]:s32
    jmpE return, app, thisApp
    hasAdminPerm cond, app
    jmpNZ return, cond
    throw permErr
    LBL return
END

# Adds a new line to `lines`, resizing `lines` if necessary.
FUNC createLine, 0, guarded
    ARG dest, s32
    # Pointer to array of text allocations.
    ARG lines, s32
    ARG lineCount, s16
    
    # Create the new line.
    VAR index, s32
    VAR size, s32
    newAlloc dest, guardedAllocAttr, termWidth
    fillBuff dest[0]:s8, termWidth, 32:s8
    mul index, lineCount, 4
    allocSize size, lines
    jmpG skipResize, size, index
    
    # Resize `lines` if it is not big enough to fit the new line.
    VAR newSize, s32
    mul newSize, size, 2
    VAR newLines, s32
    newAlloc newLines, guardedAllocAttr, newSize
    wrtBuff newLines[0]:s8, lines[0]:s8, size
    delAlloc lines
    wrt lines, newLines
    
    # Add the new line to the end of `lines`.
    LBL skipResize
    wrt lines[index]:s32, dest
    inc lineCount
END

# Splits `message` into lines, wrapping text so that words are not broken.
# Stores the lines in the `messageLines` field of `window`.
FUNC splitMessage, 0, guarded
    ARG window, s32
    # Pointer to text allocation.
    ARG message, s32
    
    VAR char, s8
    VAR size, s32
    
    # Return if `message` is null.
    jmpNZ skipNull, message
    wrt window[messageLineAmount_OFFSET]:s16, 0
    ret
    LBL skipNull
    
    # Initialize local variables.
    VAR messageSize, s32
    VAR messageIndex, s32
    VAR lines, s32
    VAR lineCount, s16
    VAR line, s32
    VAR lineIndex, s32
    allocSize messageSize, message
    wrt messageIndex, 0
    newAlloc lines, guardedAllocAttr, 20
    wrt lineCount, 0
    callCreateLine line, lineIndex, lines, lineCount
    
    # Loop while `messageIndex` is less than the size of `message`.
    LBL splitLoop
    jmpNG breakSplit, messageSize, messageIndex
    
    # Skip spaces, and store the index in `wordStartIndex`.
    VAR wordStartIndex, s32
    wrt wordStartIndex, messageIndex
    LBL spaceLoop
    jmpNG breakSpace, messageSize, wordStartIndex
    jmpNE breakSpace, message[wordStartIndex]:s8, 32
    inc wordStartIndex
    jmp spaceLoop
    LBL breakSpace
    
    # Skip word characters, and store the result in `wordEndIndex`.
    VAR wordEndIndex, s32
    wrt wordEndIndex, wordStartIndex
    wrt size, 0
    LBL wordLoop
    jmpNG breakWord, messageSize, wordEndIndex
    jmpNG breakWord, termWidth, size
    wrt char, message[wordEndIndex]:s8
    jmpG breakWord, 33, char
    jmpG breakWord, char, 126
    inc wordEndIndex
    inc size
    jmpE breakWord, char, 45
    jmpNE wordLoop, char, 47
    LBL breakWord
    
    # Branch based on the size of the new word.
    sub size, wordEndIndex, messageIndex
    VAR lineEndIndex, s32
    add lineEndIndex, lineIndex, size
    jmpNG skipCreateLine, lineEndIndex, termWidth
    
    # If the new word exceeds the size of the current line, create a new line.
    callCreateLine line, lineIndex, lines, lineCount
    wrt messageIndex, wordStartIndex
    sub size, wordEndIndex, messageIndex
    
    # Write the word into the current line.
    LBL skipCreateLine
    wrtBuff line[lineIndex]:s8, message[messageIndex]:s8, size
    add lineIndex, prevArg, size
    wrt messageIndex, wordEndIndex
    
    # Handle non-printable characters and newline characters.
    LBL specialLoop
    jmpNG breakSpecial, messageSize, messageIndex
    wrt char, message[messageIndex]:s8
    jmpG breakSpecial, char, 31
    inc messageIndex
    jmpNE specialLoop, char, 10
    callCreateLine line, lineIndex, lines, lineCount
    jmp specialLoop
    LBL breakSpecial
    
    jmp splitLoop
    LBL breakSplit
    
    # Store the results in the window allocation.
    wrt window[messageLines_OFFSET]:s32, lines
    wrt window[messageLineAmount_OFFSET]:s16, lineCount
END

# Must be called with `windowsMutex`.
FUNC drawFocusedWindow, 0, guarded
    VAR index, s32
    VAR offset, s32
    VAR size, s32
    VAR ptr, s32
    VAR line, s32
    
    # Branch based on current window mode.
    VAR mode, s8
    wrt mode, focusedWindow[mode_OFFSET]:s8
    jmpE noneMode, mode, none_MODE
    
    # Initialize local variables.
    VAR posY, s16
    VAR verticalScroll, s16
    VAR messageLines, s32
    VAR messageLineAmount, s16
    wrt posY, 0
    wrt verticalScroll, focusedWindow[verticalScroll_OFFSET]:s16
    wrt messageLines, focusedWindow[messageLines_OFFSET]:s32
    wrt messageLineAmount, focusedWindow[messageLineAmount_OFFSET]:s16
    
    # Draw message lines.
    LBL messageLoop
    jmpNG stopDraw, termHeight, posY
    add index, verticalScroll, posY
    jmpNG breakMessage, messageLineAmount, index
    mul offset, index, 4
    wrt line, messageLines[offset]:s32
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    inc posY
    jmp messageLoop
    LBL breakMessage
    
    # If mode is `displayMessage_MODE`, we don't need to draw options or input text.
    jmpE emptyLineLoop, mode, displayMessage_MODE
    
    # Initialize more local variables.
    VAR input, s32
    VAR inputLen, s16
    VAR cursorIndex, s16
    wrt input, focusedWindow[input_OFFSET]:s32
    wrt inputLen, focusedWindow[inputLen_OFFSET]:s16
    wrt cursorIndex, focusedWindow[inputCursorIndex_OFFSET]:s16
    add index, verticalScroll, posY
    sub index, prevArg, messageLineAmount
    jmpNG skipUnderflow, 0, index
    wrt index, 0
    LBL skipUnderflow
    newAlloc line, guardedAllocAttr, termWidth
    
    jmpE handlePromptText, mode, promptText_MODE
    
    # Draw options when mode is `promptOption_MODE`.
    VAR tempSize, s32
    sub tempSize, termWidth, 1
    LBL optionLoop
    jmpNG cleanUpLine, termHeight, posY
    jmpNG cleanUpLine, inputLen, index
    fillBuff line[0]:s8, termWidth, 32:s8
    mul offset, index, 4
    wrt ptr, input[offset]:s32
    allocSize size, ptr
    jmpE handleCursor, index, cursorIndex
    wrt offset, 0
    jmp skipCursor1
    LBL handleCursor
    wrt line[0]:s8, 62
    wrt offset, focusedWindow[inputHorizontalScroll_OFFSET]:s16
    LBL skipCursor1
    sub size, prevArg, offset
    jmpNG skipResize1, size, tempSize
    wrt size, tempSize
    LBL skipResize1
    wrtBuff line[1]:s8, ptr[offset]:s8, size
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    inc index
    inc posY
    jmp optionLoop
    
    # Draw input text when mode is `promptText_MODE`.
    LBL handlePromptText
    mul index, prevArg, termWidth
    LBL textLoop
    jmpNG cleanUpLine, termHeight, posY
    jmpG cleanUpLine, index, inputLen
    fillBuff line[0]:s8, termWidth, 32:s8
    sub size, inputLen, index
    jmpG skipText, 0, size
    jmpG skipResize2, termWidth, size
    wrt size, termWidth
    LBL skipResize2
    wrtBuff line[0]:s8, input[index]:s8, size
    LBL skipText
    sub offset, cursorIndex, index
    jmpG skipCursor2, 0, offset
    jmpNG skipCursor2, termWidth, offset
    wrt line[offset]:s8, 95
    LBL skipCursor2
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    add index, prevArg, termWidth
    inc posY
    jmp textLoop
    
    LBL cleanUpLine
    delAlloc line
    
    # Fill the rest of the space with empty lines.
    LBL emptyLineLoop
    jmpNG stopDraw, termHeight, posY
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, emptyLine
    callRemote termHandle, wrtTermIndex
    inc posY
    jmp emptyLineLoop
    
    LBL stopDraw
    ret
    
    # Draw window when mode is `none_MODE`.
    LBL noneMode
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.text, focusedWindow[termBuff_OFFSET]:s32
    callRemote termHandle, wrtTermIndex
END

FUNC drawWindowIfFocused, 0, guarded
    ARG window, s32
    
    waitGate windowsMutex
    jmpNE skipDraw, window, focusedWindow
    call drawFocusedWindow
    LBL skipDraw
    openGate windowsMutex
END

FUNC focusWindow, 0, guarded
    ARG window, s32
    
    VAR lastWindow, s32
    VAR funcIndex, s32
    
    # Only focus the window if it is not already focused.
    waitGate windowsMutex
    jmpE cancelFocus, window, focusedWindow
    wrt lastWindow, focusedWindow
    wrt focusedWindow, window
    call drawFocusedWindow
    openGate windowsMutex
    
    # Call `windowFocusChanged` on the owner of the last focused window.
    jmpZ skipBlur, lastWindow
    wrt funcIndex, lastWindow[focusChangedIndex_OFFSET]:s32
    jmpG skipBlur, 0, funcIndex
    newArgFrame wsWindowFocusChanged.argsSize
    wrt wsWindowFocusChanged.args.window, lastWindow
    wrt wsWindowFocusChanged.args.hasFocus, 0
    setErrJmp blurErr
    callRemote lastWindow[owner_OFFSET]:s32, funcIndex
    LBL blurErr
    clrErrJmp
    LBL skipBlur
    
    # Call `windowFocusChanged` on the owner of the new window to focus.
    wrt funcIndex, window[focusChangedIndex_OFFSET]:s32
    jmpG skipFocus, 0, funcIndex
    newArgFrame wsWindowFocusChanged.argsSize
    wrt wsWindowFocusChanged.args.window, window
    wrt wsWindowFocusChanged.args.hasFocus, 1
    setErrJmp focusErr
    callRemote window[owner_OFFSET]:s32, funcIndex
    LBL focusErr
    clrErrJmp
    LBL skipFocus
    ret
    
    LBL cancelFocus
    openGate windowsMutex
END

# When the user presses a key and `window` is focused,
# `waitForKey` stores the pressed key in `dest`.
FUNC waitForKey, 0, guarded
    ARG dest, s8
    ARG window, s32
    
    # Wait for `keyGate`.
    VAR ackGate, s32
    wrt ackGate, window[ackGate_OFFSET]:s32
    waitGate window[keyGate_OFFSET]:s32
    
    # If the window is marked for deletion, store zero in `dest`.
    jmpE readKey, window[cleanUpState_OFFSET]:s8, none_CLEAN_UP_STATE
    wrt dest, 0
    ret
    
    # Wait for non-zero key, then set `key` field back to zero.
    LBL readKey
    openGate ackGate
    LBL keyLoop
    wrt dest, window[key_OFFSET]:s8
    jmpZ keyLoop, dest
    closeGate ackGate
    wrt window[key_OFFSET]:s8, 0
END

# Cleans up garbage and sets mode back to `none_MODE`.
# Throw `missingErr` if the window is marked for deletion.
FUNC cleanUpMode, 0, guarded
    ARG window, s32
    
    VAR messageLines, s32
    VAR messageLineAmount, s16
    VAR index, s16
    VAR offset, s32
    VAR cleanUpState, s8
    wrt messageLines, window[messageLines_OFFSET]:s32
    jmpZ skipDelMessage, messageLines
    wrt messageLineAmount, window[messageLineAmount_OFFSET]:s32
    wrt index, 0
    LBL lineLoop
    jmpNG breakLine, messageLineAmount, index
    mul offset, index, 4
    delAlloc messageLines[offset]:s32
    inc index
    jmp lineLoop
    LBL breakLine
    delAlloc window[messageLines_OFFSET]:s32
    LBL skipDelMessage
    wrt cleanUpState, window[cleanUpState_OFFSET]:s8
    openGate window[ackGate_OFFSET]:s32
    wrt window[mode_OFFSET]:s8, none_MODE
    jmpE skipErr, cleanUpState, none_CLEAN_UP_STATE
    throw missingErr
    LBL skipErr
END

FUNC newWindow, wsNewWindow.id
    ARG dest, s32
    ARG title, s32
    
    VAR windowIndex, s16
    VAR title2, s32
    VAR size, s16
    VAR ptr, s32
    VAR name, s32
    
    # Initialize field members of the new window allocation.
    newAlloc dest, guardedAllocAttr | sentryAllocAttr, window_SIZE
    caller ptr
    fileName name, ptr
    openFile ptr, name
    delAlloc name
    wrt dest[owner_OFFSET]:s32, ptr
    newGate dest[keyGate_OFFSET]:s32, 0
    newGate dest[ackGate_OFFSET]:s32, 0
    closeGate dest[keyGate_OFFSET]:s32
    findFunc dest[reqDelIndex_OFFSET]:s32, ptr, wsReqDelWindow.id
    findFunc dest[keyPressedIndex_OFFSET]:s32, ptr, wsWindowKeyPressed.id
    findFunc dest[focusChangedIndex_OFFSET]:s32, ptr, wsWindowFocusChanged.id
    jmpZ missingTitle, title
    allocSize size, title
    newAlloc title2, guardedAllocAttr, size
    wrtBuff title2[0]:s8, title[0]:s8, size
    jmp skipMissingTitle
    LBL missingTitle
    fileName title2, ptr
    LBL skipMissingTitle
    wrt dest[title_OFFSET]:s32, title2
    newAlloc ptr, guardedAllocAttr, termBuffSize
    fillBuff ptr[0]:s8, termBuffSize, 32:s8
    wrt dest[termBuff_OFFSET]:s32, ptr
    
    waitGate windowsMutex
    mul windowIndex, windowCount, 4
    allocSize size, windows
    jmpG skipResize, size, windowIndex
    
    # Resize `windows` if we cannot fit the new window.
    VAR newSize, s16
    mul newSize, size, 2
    newAlloc ptr, guardedAllocAttr, newSize
    wrtBuff ptr[0]:s8, windows[0]:s8, size
    delAlloc windows
    wrt windows, ptr
    
    # Add the new window to the end of `windows`.
    LBL skipResize
    wrt windows[windowIndex]:s32, dest
    inc windowCount
    openGate windowsMutex
    
    # Focus the new window.
    newArgFrame focusWindow.argsSize
    wrt focusWindow.args.window, dest
    call focusWindow
END

FUNC delWindow, wsDelWindow.id
    ARG window, s32
    callCheckPerm window
    
    # Request for the window mode to become `none_MODE`.
    wrt window[cleanUpState_OFFSET]:s8, prepare_CLEAN_UP_STATE
    openGate window[keyGate_OFFSET]:s32
    
    # If the window is focused, focus the shell window.
    jmpNE skipFocus, window, focusedWindow
    waitGate windowsMutex
    wrt focusedWindow, null
    openGate windowsMutex
    newArgFrame focusWindow.argsSize
    wrt focusWindow.args.window, shellWindow
    call focusWindow
    LBL skipFocus
    
    # Wait for window mode to become `none_MODE`
    LBL modeLoop
    waitGate window[ackGate_OFFSET]:s32
    jmpNE modeLoop, window[mode_OFFSET]:s8, none_MODE
    wrt window[cleanUpState_OFFSET]:s8, delete_CLEAN_UP_STATE
    openGate delWindowGate
END

FUNC displayWindowMessage, wsDisplayWindowMessage.id
    ARG dest, s8
    ARG window, s32
    ARG message, s32
    
    VAR verticalScroll, s32
    VAR index, s32
    
    # Split `message` into lines.
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    
    # Initialize local variables and fields in `window`.
    wrt verticalScroll, 0
    wrt window[mode_OFFSET]:s8, displayMessage_MODE
    closeGate window[ackGate_OFFSET]:s32
    wrt window[key_OFFSET]:s8, 0
    
    # Draw the window.
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s16, verticalScroll
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    # Register the next pressed key.
    LBL keyLoop
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    jmpE enterPressed, key, 10
    jmpE escapePressed, key, 27
    jmpE upPressed, key, -3
    jmpE downPressed, key, -4
    jmpE tabPressed, key, 9
    jmpE rtabPressed, key, -5
    jmpZ cleanUp, key
    jmp keyLoop
    
    # Scroll up.
    LBL upPressed
    jmpNG keyLoop, verticalScroll, 0
    dec verticalScroll
    jmp drawLoop
    
    # Scroll down.
    LBL downPressed
    add index, verticalScroll, termHeight
    jmpNG keyLoop, window[messageLineAmount_OFFSET]:s16, index
    inc verticalScroll
    jmp drawLoop
    
    # Scroll to the end of the message.
    LBL tabPressed
    sub verticalScroll, window[messageLineAmount_OFFSET]:s16, termHeight
    jmpNG drawLoop, 0, verticalScroll
    wrt verticalScroll, 0
    jmp drawLoop
    
    # Scroll to the beginning of the message.
    LBL rtabPressed
    wrt verticalScroll, 0
    jmp drawLoop
    
    # Store whether the enter or escape key was pressed.
    LBL enterPressed
    wrt dest, 0
    jmp cleanUp
    LBL escapePressed
    wrt dest, 1
    
    # Clean up garbage and state.
    LBL cleanUp
    newArgFrame cleanUpMode.argsSize
    wrt cleanUpMode.args.window, window
    call cleanUpMode
END

FUNC promptWindowOption, wsPromptWindowOption.id
    ARG dest, s16
    ARG window, s32
    ARG message, s32
    ARG options, s32
    
    VAR messageLineAmount, s16
    VAR verticalScroll, s16
    VAR horizontalScroll, s16
    VAR cursorIndex, s16
    VAR cursorPosY, s16
    VAR optionAmount, s16
    VAR totalLineAmount, s16
    VAR index, s32
    
    # Split `message` into lines.
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    
    # Initialize local variables and fields in `window`.
    wrt messageLineAmount, window[messageLineAmount_OFFSET]:s16
    wrt verticalScroll, 0
    wrt horizontalScroll, 0
    wrt cursorIndex, 0
    allocSize optionAmount, options
    div optionAmount, prevArg, 4
    add totalLineAmount, messageLineAmount, optionAmount
    wrt window[input_OFFSET]:s32, options
    wrt window[inputLen_OFFSET]:s16, optionAmount
    wrt window[mode_OFFSET]:s8, promptOption_MODE
    closeGate window[ackGate_OFFSET]:s32
    wrt window[key_OFFSET]:s8, 0
    
    # Draw the window.
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s16, verticalScroll
    wrt window[inputHorizontalScroll_OFFSET]:s16, horizontalScroll
    wrt window[inputCursorIndex_OFFSET]:s16, cursorIndex
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    # Register the next pressed key.
    LBL keyLoop
    add cursorPosY, messageLineAmount, cursorIndex
    sub cursorPosY, prevArg, verticalScroll
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    jmpE enterPressed, key, 10
    jmpE escapePressed, key, 27
    jmpE upPressed, key, -3
    jmpE downPressed, key, -4
    jmpE leftPressed, key, -1
    jmpE rightPressed, key, -2
    jmpE tabPressed, key, 9
    jmpE rtabPressed, key, -5
    jmpZ cleanUp, key
    jmp keyLoop
    
    # Scroll up or select the previous option.
    LBL upPressed
    jmpNG scroll1, cursorIndex, 0
    jmpG skipScroll1, cursorPosY, 0
    LBL scroll1
    dec verticalScroll
    LBL skipScroll1
    jmpNG skipCursor1, cursorIndex, 0
    jmpNG skipCursor1, termHeight, cursorPosY
    dec cursorIndex
    LBL skipCursor1
    jmp alignBounds
    
    # Scroll down or select the next option.
    LBL downPressed
    sub index, termHeight, 1
    jmpG skipScroll2, index, cursorPosY
    inc verticalScroll
    LBL skipScroll2
    sub index, optionAmount, 1
    jmpNG skipCursor2, index, cursorIndex
    jmpNG skipCursor2, termHeight, cursorPosY
    inc cursorIndex
    LBL skipCursor2
    jmp alignBounds
    
    # Scroll the current option left.
    LBL leftPressed
    sub horizontalScroll, prevArg, 4
    jmpNG drawLoop, 0, horizontalScroll
    wrt horizontalScroll, 0
    jmp drawLoop
    
    # Scroll the current option right.
    LBL rightPressed
    add horizontalScroll, prevArg, 4
    mul index, cursorIndex, 4
    allocSize index, options[index]:s32
    sub index, prevArg, termWidth
    inc index
    jmpNG drawLoop, horizontalScroll, index
    wrt horizontalScroll, index
    jmpNG drawLoop, 0, horizontalScroll
    wrt horizontalScroll, 0
    jmp drawLoop
    
    # Scroll to the end of the message or all options.
    LBL tabPressed
    jmpG skipTab, termHeight, cursorPosY
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipTab
    sub verticalScroll, totalLineAmount, termHeight
    sub cursorIndex, optionAmount, 1
    jmp alignBounds
    
    # Scroll to the first option or the beginning of the message.
    LBL rtabPressed
    jmpNG skipRtab, cursorIndex, 0
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipRtab
    wrt verticalScroll, 0
    jmp alignBounds
    
    # Ensure that vertical scroll is not out of range.
    LBL alignBounds
    wrt horizontalScroll, 0
    sub index, totalLineAmount, termHeight
    jmpNG skipAlign, verticalScroll, index
    wrt verticalScroll, index
    LBL skipAlign
    jmpNG drawLoop, 0, verticalScroll
    wrt verticalScroll, 0
    jmp drawLoop
    
    # If the user presses enter but the current option is not
    # visible, scroll to the first option.
    LBL enterPressed
    jmpG acceptOption, termHeight, cursorPosY
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    
    # Store the index of the selected option, or -1 if escape was pressed.
    LBL acceptOption
    wrt dest, cursorIndex
    jmp cleanUp
    LBL escapePressed
    wrt dest, -1
    
    # Clean up garbage and state.
    LBL cleanUp
    newArgFrame cleanUpMode.argsSize
    wrt cleanUpMode.args.window, window
    call cleanUpMode
END

FUNC promptWindowText, wsPromptWindowText.id
    ARG dest, s32
    ARG window, s32
    ARG message, s32
    ARG startText, s32
    
    VAR messageLineAmount, s16
    VAR verticalScroll, s16
    VAR inputText, s32
    VAR inputTextLen, s16
    VAR cursorIndex, s16
    VAR cursorPosY, s16
    VAR index, s32
    VAR size, s32
    VAR ptr, s32
    
    # Split `message` into lines.
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    
    # Create a text allocation to store the input text.
    jmpNZ handleStartText, startText
    wrt inputTextLen, 0
    newAlloc inputText, guardedAllocAttr, 10
    wrt cursorIndex, 0
    jmp skipStartText
    LBL handleStartText
    allocSize inputTextLen, startText
    add size, inputTextLen, 10
    newAlloc inputText, guardedAllocAttr, size
    wrtBuff inputText[0]:s8, startText[0]:s8, inputTextLen
    wrt cursorIndex, inputTextLen
    LBL skipStartText
    
    # Initialize local variables and fields in `window`.
    wrt messageLineAmount, window[messageLineAmount_OFFSET]:s16
    wrt verticalScroll, 0
    wrt window[input_OFFSET]:s32, inputText
    wrt window[inputLen_OFFSET]:s16, inputTextLen
    wrt window[mode_OFFSET]:s8, promptText_MODE
    closeGate window[ackGate_OFFSET]:s32
    wrt window[key_OFFSET]:s8, 0
    
    # Draw the window.
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s16, verticalScroll
    wrt window[inputLen_OFFSET]:s16, inputTextLen
    wrt window[inputCursorIndex_OFFSET]:s16, cursorIndex
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    # Register the next pressed key.
    LBL keyLoop
    updateCursorPosY
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    jmpE deletePressed, key, 127
    jmpG charPressed, key, 31
    jmpE enterPressed, key, 10
    jmpE escapePressed, key, 27
    jmpE upPressed, key, -3
    jmpE downPressed, key, -4
    jmpE leftPressed, key, -1
    jmpE rightPressed, key, -2
    jmpE tabPressed, key, 9
    jmpE rtabPressed, key, -5
    jmpZ cleanUp, key
    jmp keyLoop
    
    # Delete the character before the cursor.
    LBL deletePressed
    jmpNG keyLoop, cursorIndex, 0
    sub index, cursorIndex, 1
    sub size, inputTextLen, cursorIndex
    jmpNG skipCopy1, size, 0
    wrtBuff inputText[index]:s8, inputText[cursorIndex]:s8, size
    LBL skipCopy1
    wrt cursorIndex, index
    dec inputTextLen
    jmp scrollToCursor
    
    # Insert a character before the cursor.
    LBL charPressed
    allocSize size, inputText
    jmpG skipResize, size, inputTextLen
    VAR newSize, s32
    mul newSize, size, 2
    newAlloc ptr, guardedAllocAttr, newSize
    wrtBuff ptr[0]:s8, inputText[0]:s8, size
    delAlloc inputText
    wrt inputText, ptr
    wrt window[input_OFFSET]:s32, inputText
    LBL skipResize
    add index, cursorIndex, 1
    sub size, inputTextLen, cursorIndex
    jmpNG skipCopy2, size, 0
    wrtBuff inputText[index]:s8, inputText[cursorIndex]:s8, size
    LBL skipCopy2
    wrt inputText[cursorIndex]:s8, key
    wrt cursorIndex, index
    inc inputTextLen
    jmp scrollToCursor
    
    # Scroll up or move the cursor up.
    LBL upPressed
    jmpZ scrollUp, cursorIndex
    jmpG moveCursorUp, termHeight, cursorPosY
    LBL scrollUp
    dec verticalScroll
    jmp alignBounds
    LBL moveCursorUp
    sub cursorIndex, prevArg, termWidth
    jmpNG scrollToCursor, 0, cursorIndex
    wrt cursorIndex, 0
    jmp scrollToCursor
    
    # Scroll down or move the cursor down.
    LBL downPressed
    jmpG moveCursorDown, termHeight, cursorPosY
    inc verticalScroll
    jmp alignBounds
    LBL moveCursorDown
    add cursorIndex, prevArg, termWidth
    jmpNG scrollToCursor, cursorIndex, inputTextLen
    wrt cursorIndex, inputTextLen
    jmp scrollToCursor
    
    # Move the cursor left.
    LBL leftPressed
    jmpNG keyLoop, cursorIndex, 0
    dec cursorIndex
    jmp scrollToCursor
    
    # Move the cursor right.
    LBL rightPressed
    jmpNG keyLoop, inputTextLen, cursorIndex
    inc cursorIndex
    jmp scrollToCursor
    
    # Scroll to the end of the message or text entry.
    LBL tabPressed
    jmpG skipTab, termHeight, cursorPosY
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipTab
    div verticalScroll, inputTextLen, termWidth
    add verticalScroll, prevArg, messageLineAmount
    wrt cursorIndex, inputTextLen
    jmp alignBounds
    
    # Scroll to the beginning of text entry or the message.
    LBL rtabPressed
    jmpNG skipRtab, cursorIndex, 0
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipRtab
    wrt verticalScroll, 0
    jmp alignBounds
    
    # Adjust vertical scroll so that the cursor is visible.
    LBL scrollToCursor
    updateCursorPosY
    jmpNG skipScrollBack, 0, cursorPosY
    div verticalScroll, cursorIndex, termWidth
    add verticalScroll, prevArg, messageLineAmount
    jmp alignBounds
    LBL skipScrollBack
    jmpG alignBounds, termHeight, cursorPosY
    div verticalScroll, cursorIndex, termWidth
    add verticalScroll, prevArg, messageLineAmount
    sub verticalScroll, prevArg, termHeight
    inc verticalScroll
    
    # Ensure that vertical scroll is not out of range.
    LBL alignBounds
    VAR totalLineAmount, s16
    div totalLineAmount, inputTextLen, termWidth
    inc totalLineAmount
    add totalLineAmount, prevArg, messageLineAmount
    sub index, totalLineAmount, termHeight
    jmpNG skipAlign, verticalScroll, index
    wrt verticalScroll, index
    LBL skipAlign
    jmpNG drawLoop, 0, verticalScroll
    wrt verticalScroll, 0
    jmp drawLoop
    
    # If the user presses enter but the cursor is not visible, scroll to the cursor.
    LBL enterPressed
    jmpG acceptText, termHeight, cursorPosY
    wrt cursorIndex, inputTextLen
    jmp scrollToCursor
    
    # Provide a pointer to a new text allocation, or null if escape was pressed.
    LBL acceptText
    newAlloc dest, 0, inputTextLen
    jmpZ cleanUp, inputTextLen
    wrtBuff dest[0]:s8, inputText[0]:s8, inputTextLen
    jmp cleanUp
    LBL escapePressed
    wrt dest, null
    
    # Clean up garbage and state.
    LBL cleanUp
    newArgFrame cleanUpMode.argsSize
    wrt cleanUpMode.args.window, window
    call cleanUpMode
END

FUNC clrWindow, wsClrWindow.id
    ARG window, s32
    callCheckPerm window
    
    # Fill the terminal buffer with spaces, and draw the window.
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    fillBuff termBuff[0]:s8, termBuffSize, 32:s8
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
END

FUNC windowTermSize, wsWindowTermSize.id
    ARG widthDest, s16
    ARG heightDest, s16
    ARG window, s32
    callCheckPerm window
    
    wrt widthDest, termWidth
    wrt heightDest, termHeight
END

FUNC readWindowTerm, wsReadWindowTerm.id
    ARG dest, s32
    ARG window, s32
    ARG x, s16
    ARG y, s16
    ARG length, s32
    callCheckPerm window
    
    # Read text from the terminal buffer of the window.
    VAR index, s32
    mul index, y, termWidth
    add index, prevArg, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    newAlloc dest, 0, length
    setErrJmp cleanUpAlloc
    wrtBuff dest[0]:s8, termBuff[index]:s8, length
    ret
    
    # Clean up the result if there was an error while reading the buffer.
    LBL cleanUpAlloc
    delAlloc dest
    VAR err, s8
    err err
    throw err
END

FUNC wrtWindowTerm, wsWrtWindowTerm.id
    ARG window, s32
    ARG x, s16
    ARG y, s16
    ARG text, s32
    callCheckPerm window
    
    # Modify the terminal buffer.
    VAR index, s32
    mul index, y, termWidth
    add index, prevArg, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    VAR size, s32
    allocSize size, text
    wrtBuff termBuff[index]:s8, text[0]:s8, size
    
    # Draw the text if the window is focused.
    waitGate windowsMutex
    jmpNE skipDraw, window, focusedWindow
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.x, x
    wrt wsWrtTerm.args.y, y
    wrt wsWrtTerm.args.text, text
    callRemote termHandle, wrtTermIndex
    LBL skipDraw
    openGate windowsMutex
END

FUNC windowFocusChanged, wsWindowFocusChanged.id, guarded
    ARG window, s32
    ARG hasFocus, s8
    jmpZ skipMainMenu, hasFocus
    openGate mainMenuGate
    LBL skipMainMenu
END

FUNC cleanUpWindow, 0, guarded
    ARG window, s32
    waitGate cleanUpGate
    closeFile window[owner_OFFSET]:s32
    delAlloc window[title_OFFSET]:s32
    delAlloc window[termBuff_OFFSET]:s32
    delGate window[keyGate_OFFSET]:s32
    delGate window[ackGate_OFFSET]:s32
    delAlloc window
    openGate cleanUpGate
END

FUNC cleanUpWindows, 0, guarded
    VAR index, s16
    VAR nextIndex, s16
    VAR endIndex, s16
    VAR sizeToMove, s16
    VAR window, s32
    VAR isRunning, s8
    
    # Iterate over each window in `windows`.
    waitGate windowsMutex
    wrt index, 0
    mul endIndex, windowCount, 4
    LBL cleanUpLoop
    jmpNG breakCleanUp, endIndex, index
    wrt window, windows[index]:s32
    
    # Clean up the window if marked for deletion, or if the owner is not running.
    jmpE cleanUp, window[cleanUpState_OFFSET]:s8, delete_CLEAN_UP_STATE
    appIsRunning isRunning, window[owner_OFFSET]:s32
    jmpZ cleanUp, isRunning
    add index, prevArg, 4
    jmp cleanUpLoop
    
    # Delete the window, and move all windows afterward to the left.
    LBL cleanUp
    newArgFrame cleanUpWindow.argsSize
    wrt cleanUpWindow.args.window, window
    call cleanUpWindow
    add nextIndex, index, 4
    sub sizeToMove, endIndex, nextIndex
    jmpZ skipMove, sizeToMove
    wrtBuff windows[index]:s8, windows[nextIndex]:s8, sizeToMove
    LBL skipMove
    dec windowCount
    sub endIndex, prevArg, 4
    jmp cleanUpLoop
    LBL breakCleanUp
    openGate windowsMutex
END

FUNC runShellMenu, 0, guarded
    VAR text, s32
    VAR options, s32
    VAR optionsSize, s16
    VAR optionIndex, s16
    VAR index, s16
    VAR index2, s16
    VAR endIndex, s16
    VAR window, s32
    VAR menuWindows, s32
    VAR menuWindowCount, s8
    VAR size, s16
    VAR ptr, s32
    VAR cond, s8
    
    # Acquire a file handle to the file manager.
    newTextAlloc text, fileManagerNameStart, fileManagerNameEnd
    openFile fileManagerHandle, text
    delAlloc text
    
    # Display a welcome message.
    newTextAlloc text, welcomeMessageStart, welcomeMessageEnd
    newArgFrame displayWindowMessage.argsSize
    wrt displayWindowMessage.args.window, shellWindow
    wrt displayWindowMessage.args.message, text
    call displayWindowMessage
    delAlloc text
    
    # Initialize text allocations for menus.
    VAR windowsTitle, s32
    VAR fileManagerTitle, s32
    VAR windowOptions, s32
    VAR fileManagerOptions, s32
    newTextAlloc windowsTitle, windowsTitleStart, windowsTitleEnd
    newTextAlloc fileManagerTitle, fileManagerTitleStart, fileManagerTitleEnd
    newAlloc windowOptions, guardedAllocAttr, 12
    newTextAlloc text, viewOptionStart, viewOptionEnd
    wrt windowOptions[0]:s32, text
    newTextAlloc text, closeOptionStart, closeOptionEnd
    wrt windowOptions[4]:s32, text
    newTextAlloc text, quitOptionStart, quitOptionEnd
    wrt windowOptions[8]:s32, text
    newAlloc fileManagerOptions, guardedAllocAttr, 4
    newTextAlloc text, launchOptionStart, launchOptionEnd
    wrt fileManagerOptions[0]:s32, text
    
    # Enter a loop cleaning up windows and displaying menus.
    LBL mainMenu
    call cleanUpWindows
    
    # Determine the set of windows which should be displayed in the menu.
    # Null represents the file manager when it is not open yet.
    VAR hasFileManager, s8
    wrt hasFileManager, 0
    waitGate windowsMutex
    mul endIndex, windowCount, 4
    add size, endIndex, endIndex
    newAlloc menuWindows, guardedAllocAttr, size
    wrt menuWindowCount, 0
    wrt index, 0
    wrt index2, 0
    LBL windowsLoop
    jmpNG breakWindows, endIndex, index
    wrt window, windows[index]:s32
    add index, prevArg, 4
    jmpE windowsLoop, window, shellWindow
    jmpNE skipHasFileManager, window[owner_OFFSET]:s32, fileManagerHandle
    wrt hasFileManager, 1
    LBL skipHasFileManager
    wrt menuWindows[index2]:s32, window
    add index2, prevArg, 4
    inc menuWindowCount
    jmp windowsLoop
    LBL breakWindows
    openGate windowsMutex
    jmpNZ skipAddFileManager, hasFileManager
    wrt menuWindows[index2]:s32, null
    inc menuWindowCount
    LBL skipAddFileManager
    
    # Create the list of text allocations for the options prompt.
    mul optionsSize, menuWindowCount, 4
    newAlloc options, guardedAllocAttr, optionsSize
    wrt index, 0
    LBL optionsLoop
    jmpNG breakOptions, optionsSize, index
    wrt window, menuWindows[index]:s32
    jmpZ fileManagerOption, window
    wrt text, window[title_OFFSET]:s32
    jmp skipFileManagerOption
    LBL fileManagerOption
    wrt text, fileManagerTitle
    LBL skipFileManagerOption
    wrt options[index]:s32, text
    add index, prevArg, 4
    jmp optionsLoop
    LBL breakOptions
    
    # Display the options prompt.
    newArgFrame promptWindowOption.argsSize
    wrt promptWindowOption.args.window, shellWindow
    wrt promptWindowOption.args.message, windowsTitle
    wrt promptWindowOption.args.options, options
    call promptWindowOption
    mul optionIndex, promptWindowOption.args.dest, 4
    delAlloc options
    jmpG mainMenu, 0, optionIndex
    wrt window, menuWindows[optionIndex]:s32
    jmpZ fileManagerMenu, window
    
    # Display a menu for the selected window.
    newArgFrame promptWindowOption.argsSize
    wrt promptWindowOption.args.window, shellWindow
    wrt promptWindowOption.args.message, window[title_OFFSET]:s32
    wrt promptWindowOption.args.options, windowOptions
    call promptWindowOption
    wrt optionIndex, promptWindowOption.args.dest
    jmpE viewWindow, optionIndex, 0
    jmpE closeWindow, optionIndex, 1
    jmpE quitApp, optionIndex, 2
    jmp mainMenu
    
    # Focus the window.
    LBL viewWindow
    newArgFrame focusWindow.argsSize
    wrt focusWindow.args.window, window
    call focusWindow
    jmp waitForFocus
    
    # Request for the window to be deleted.
    LBL closeWindow
    wrt index, window[reqDelIndex_OFFSET]:s32
    jmpG hardCloseWindow, 0, index
    setErrJmp closeWindowErr
    callRemote window[owner_OFFSET]:s32, index
    jmp delWindowLoop
    LBL closeWindowErr
    clrErrJmp
    jmp mainMenu
    LBL delWindowLoop
    jmpE mainMenu, window[cleanUpState_OFFSET]:s8, delete_CLEAN_UP_STATE
    waitGate delWindowGate
    jmp delWindowLoop
    LBL hardCloseWindow
    newArgFrame delWindow.argsSize
    wrt delWindow.args.window, window
    call delWindow
    jmp mainMenu
    
    # Kill the owner of the window.
    LBL quitApp
    wrt ptr, window[owner_OFFSET]:s32
    fileName text, ptr
    openFile ptr, text
    delAlloc text
    killApp ptr
    LBL aliveLoop
    appIsRunning cond, ptr
    jmpNZ aliveLoop, cond
    closeFile ptr
    jmp mainMenu
    
    # Display a menu for the file manager when it is not running yet.
    LBL fileManagerMenu
    newArgFrame promptWindowOption.argsSize
    wrt promptWindowOption.args.window, shellWindow
    wrt promptWindowOption.args.message, fileManagerTitle
    wrt promptWindowOption.args.options, fileManagerOptions
    call promptWindowOption
    wrt optionIndex, promptWindowOption.args.dest
    jmpE launchFileManager, optionIndex, 0
    jmp mainMenu
    
    # Launch the file manager.
    LBL launchFileManager
    appIsRunning cond, fileManagerHandle
    jmpNZ mainMenu, cond
    launch fileManagerHandle
    jmp waitForFocus
    
    # Wait until the shell window gains focus again.
    LBL waitForFocus
    newArgFrame clrWindow.argsSize
    wrt clrWindow.args.window, shellWindow
    call clrWindow
    waitGate mainMenuGate
    jmp mainMenu
END

APP_DATA
    LBL termNameStart
    DATA "wsTerm"
    LBL termNameEnd
    LBL fileManagerNameStart
    DATA "fileManager"
    LBL fileManagerNameEnd
    LBL dummyNameStart
    DATA "dummy"
    LBL dummyNameEnd
    LBL welcomeMessageStart
    DATA "Welcome to WheatSystem!\nVersion 1.0.0"
    LBL welcomeMessageEnd
    LBL windowsTitleStart
    DATA "Windows:"
    LBL windowsTitleEnd
    LBL fileManagerTitleStart
    DATA "File Manager"
    LBL fileManagerTitleEnd
    LBL viewOptionStart
    DATA "View window"
    LBL viewOptionEnd
    LBL closeOptionStart
    DATA "Close window"
    LBL closeOptionEnd
    LBL quitOptionStart
    DATA "Quit app"
    LBL quitOptionEnd
    LBL launchOptionStart
    DATA "Launch app"
    LBL launchOptionEnd
END


