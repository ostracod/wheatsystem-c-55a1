
INCLUDE "../macros.wbasm"

MACRO releaseMutex
    wrt mutexFlag, 0
END

MACRO callCheckPerm, window
    newArgFrame checkPerm.argsSize
    caller checkPerm.args.app
    wrt checkPerm.args.window, window
    call checkPerm
END

MACRO callCreateLine, dest, lineIndex, lines, lineCount
    newArgFrame createLine.argsSize
    wrt createLine.args.lines, lines
    wrt createLine.args.lineCount, lineCount
    call createLine
    wrt dest, createLine.args.dest
    wrt lines, createLine.args.lines
    wrt lineCount, createLine.args.lineCount
    wrt lineIndex, 0
END

DEF none_MODE, 0
DEF displayMessage_MODE, 1
DEF promptOption_MODE, 2
DEF promptText_MODE, 3

DEF owner_OFFSET, 0
DEF hasReqDel_OFFSET, 4
DEF title_OFFSET, 5
DEF mode_OFFSET, 9
DEF termBuff_OFFSET, 10
DEF verticalScroll_OFFSET, 14
DEF messageLines_OFFSET, 18
DEF messageLineAmount_OFFSET, 22
DEF input_OFFSET, 26
DEF inputLen_OFFSET, 30
DEF inputHorizontalScroll_OFFSET, 34
DEF inputCursorIndex_OFFSET, 38
DEF key_OFFSET, 42
DEF window_SIZE, 43

VAR thisApp, s32
VAR mutexFlag, s8
VAR windows, s32
VAR windowCount, s8
VAR focusedWindow, s32
VAR shellWindow, s32

VAR termHandle, s32
VAR wrtTermIndex, s32
VAR termWidth, s32
VAR termHeight, s32
VAR termBuffSize, s32
VAR emptyLine, s32

FUNC init, wsInit.id, guarded
    
    thisApp thisApp
    wrt mutexFlag, 0
    newAlloc windows, guardedAllocAttr, 20
    wrt windowCount, 0
    
    VAR termName, s32
    newTextAlloc termName, termNameStart, termNameEnd
    openFile termHandle, termName
    delAlloc termName
    launch termHandle
    findFunc wrtTermIndex, termHandle, wsWrtTerm.id
    VAR funcIndex, s32
    findFunc funcIndex, termHandle, wsTermSize.id
    newArgFrame wsTermSize.argsSize
    callRemote termHandle, funcIndex
    wrt termWidth, wsTermSize.args.widthDest
    wrt termHeight, wsTermSize.args.heightDest
    mul termBuffSize, termWidth, termHeight
    
    newAlloc emptyLine, guardedAllocAttr, termWidth
    VAR cond, s8
    VAR index, s32
    wrt index, 0
    LBL emptyLineLoop
    wrt emptyLine[index]:s8, 32
    add index, index, 1
    gre cond, termWidth, index
    jmpNZ emptyLineLoop, cond
    
    findFunc funcIndex, termHandle, wsListenTerm.id
    callRemote termHandle, funcIndex
    
    newArgFrame newWindow.argsSize
    call newWindow
    wrt shellWindow, newWindow.args.dest
    VAR testMessage, s32
    newTextAlloc testMessage, testMessageStart, testMessageEnd
    newArgFrame displayWindowMessage.argsSize
    wrt displayWindowMessage.args.window, shellWindow
    wrt displayWindowMessage.args.message, testMessage
    call displayWindowMessage
    newArgFrame clrWindow.argsSize
    wrt clrWindow.args.window, shellWindow
    call clrWindow
END

FUNC termInput, wsTermInput.id, guarded
    ARG key, s8
    
    VAR cond, s8
    
    VAR window, s32
    wrt window, focusedWindow
    equ cond, window[mode_OFFSET]:s8, none_MODE
    jmpZ resumeWithKey, cond
    newArgFrame wsWindowKeyPressed.argsSize
    wrt wsWindowKeyPressed.args.window, window
    wrt wsWindowKeyPressed.args.key, key
    callRemote window[owner_OFFSET]:s32, wsWindowKeyPressed.id
    ret
    
    LBL resumeWithKey
    wrt window[key_OFFSET]:s8, key
    LBL resumeLoop
    resume
    jmpZ breakResume, window[key_OFFSET]:s8
    equ cond, window[mode_OFFSET]:s8, none_MODE
    jmpZ resumeLoop, cond
    wrt window[key_OFFSET]:s8, 0
    LBL breakResume
END

# Must be called when accessing `windows`, `windowCount`, or `focusedWindow`.
FUNC acquireMutex, 0, guarded
    VAR oldValue, s8
    LBL loop
    testAndSet oldValue, mutexFlag
    jmpNZ loop, oldValue
END

FUNC checkPerm, 0, guarded
    ARG app, s32
    ARG window, s32
    
    VAR cond, s8
    equ cond, app, window[owner_OFFSET]:s32
    jmpNZ return, cond
    equ cond, app, thisApp
    jmpNZ return, cond
    hasAdminPerm cond, app
    jmpNZ return, cond
    throw permErr
    LBL return
END

FUNC clrTermBuff, 0, guarded
    ARG termBuff, s32
    
    VAR cond, s8
    VAR index, s32
    wrt index, 0
    LBL loop
    wrt termBuff[index]:s8, 32
    add index, index, 1
    gre cond, termBuffSize, index
    jmpNZ loop, cond
END

FUNC createLine, 0, guarded
    ARG dest, s32
    ARG lines, s32
    ARG lineCount, s32
    
    VAR index, s32
    VAR size, s32
    newAlloc dest, guardedAllocAttr, termWidth
    wrtBuff dest[0]:s8, emptyLine[0]:s8, termWidth
    mul index, lineCount, 4
    allocSize size, lines
    VAR cond, s8
    gre cond, size, index
    jmpNZ skipResize, cond
    
    VAR newSize, s32
    mul newSize, size, 2
    VAR newLines, s32
    newAlloc newLines, guardedAllocAttr, newSize
    wrtBuff newLines[0]:s8, lines[0]:s8, size
    delAlloc lines
    wrt lines, newLines
    
    LBL skipResize
    wrt lines[index]:s32, dest
    add lineCount, lineCount, 1
END

FUNC splitMessage, 0, guarded
    ARG window, s32
    ARG message, s32
    
    VAR cond, s8
    VAR char, s8
    
    VAR messageSize, s32
    VAR messageIndex, s32
    allocSize messageSize, message
    wrt messageIndex, 0
    
    VAR lines, s32
    VAR lineCount, s32
    VAR line, s32
    VAR lineIndex, s32
    newAlloc lines, guardedAllocAttr, 20
    wrt lineCount, 0
    callCreateLine line, lineIndex, lines, lineCount
    
    LBL splitLoop
    gre cond, messageSize, messageIndex
    jmpZ breakSplit, cond
    
    VAR wordStartIndex, s32
    wrt wordStartIndex, messageIndex
    LBL spaceLoop
    gre cond, messageSize, wordStartIndex
    jmpZ breakSpace, cond
    equ cond, message[wordStartIndex]:s8, 32
    jmpZ breakSpace, cond
    add wordStartIndex, wordStartIndex, 1
    jmp spaceLoop
    LBL breakSpace
    
    VAR wordEndIndex, s32
    wrt wordEndIndex, wordStartIndex
    LBL wordLoop
    gre cond, messageSize, wordEndIndex
    jmpZ breakWord, cond
    wrt char, message[wordEndIndex]:s8
    gre cond, 33, char
    jmpNZ breakWord, cond
    gre cond, char, 126
    jmpNZ breakWord, cond
    add wordEndIndex, wordEndIndex, 1
    equ cond, char, 45
    jmpNZ breakWord, cond
    equ cond, char, 47
    jmpZ wordLoop, cond
    LBL breakWord
    
    VAR size, s32
    sub size, wordEndIndex, messageIndex
    VAR lineEndIndex, s32
    add lineEndIndex, lineIndex, size
    gre cond, lineEndIndex, termWidth
    jmpZ skipCreateLine, cond
    
    callCreateLine line, lineIndex, lines, lineCount
    wrt messageIndex, wordStartIndex
    sub size, wordEndIndex, messageIndex
    
    LBL skipCreateLine
    wrtBuff line[lineIndex]:s8, message[messageIndex]:s8, size
    add lineIndex, lineIndex, size
    wrt messageIndex, wordEndIndex
    
    LBL specialLoop
    gre cond, messageSize, messageIndex
    jmpZ breakSpecial, cond
    wrt char, message[messageIndex]:s8
    gre cond, char, 31
    jmpNZ breakSpecial, cond
    add messageIndex, messageIndex, 1
    equ cond, char, 10
    jmpZ specialLoop, cond
    callCreateLine line, lineIndex, lines, lineCount
    jmp specialLoop
    LBL breakSpecial
    
    jmp splitLoop
    LBL breakSplit
    
    wrt window[messageLines_OFFSET]:s32, lines
    wrt window[messageLineAmount_OFFSET]:s32, lineCount
END

# Must be called between `acquireMutex` and `releaseMutex`.
FUNC drawFocusedWindow, 0, guarded
    VAR cond, s8
    VAR index, s32
    VAR offset, s32
    
    VAR mode, s8
    wrt mode, focusedWindow[mode_OFFSET]:s8
    equ cond, mode, none_MODE
    jmpNZ noneMode, cond
    
    VAR line, s32
    VAR messageLines, s32
    VAR messageLineAmount, s32
    VAR posY, s32
    wrt messageLines, focusedWindow[messageLines_OFFSET]:s32
    wrt messageLineAmount, focusedWindow[messageLineAmount_OFFSET]:s32
    wrt posY, 0
    LBL lineLoop
    gre cond, termHeight, posY
    jmpZ breakLine, cond
    add index, focusedWindow[verticalScroll_OFFSET]:s32, posY
    gre cond, index, -1
    jmpZ useEmptyLine, cond
    gre cond, messageLineAmount, index
    jmpZ useEmptyLine, cond
    mul offset, index, 4
    wrt line, messageLines[offset]:s32
    jmp skipEmptyLine
    LBL useEmptyLine
    wrt line, emptyLine
    LBL skipEmptyLine
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    add posY, posY, 1
    jmp lineLoop
    LBL breakLine
    ret
    
    LBL noneMode
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.text, focusedWindow[termBuff_OFFSET]:s32
    callRemote termHandle, wrtTermIndex
END

FUNC drawWindowIfFocused, 0, guarded
    ARG window, s32
    
    call acquireMutex
    VAR cond, s8
    equ cond, window, focusedWindow
    jmpZ skipDraw, cond
    call drawFocusedWindow
    LBL skipDraw
    releaseMutex
END

FUNC waitForKey, 0, guarded
    ARG dest, s8
    ARG window, s32
    
    LBL waitLoop
    wait
    wrt dest, window[key_OFFSET]:s8
    jmpZ waitLoop, dest
    
    wrt window[key_OFFSET]:s8, 0
END

FUNC newWindow, wsNewWindow.id
    ARG dest, s32
    ARG title, s32
    
    VAR windowIndex, s32
    VAR size, s32
    VAR cond, s8
    VAR ptr, s32
    
    newAlloc dest, guardedAllocAttr | sentryAllocAttr, window_SIZE
    caller ptr
    wrt dest[owner_OFFSET]:s32, ptr
    jmpNZ skipCreateTitle, title
    fileName title, ptr
    LBL skipCreateTitle
    wrt dest[title_OFFSET]:s32, title
    newAlloc ptr, guardedAllocAttr, termBuffSize
    newArgFrame clrTermBuff.argsSize
    wrt clrTermBuff.args.termBuff, ptr
    call clrTermBuff
    wrt dest[termBuff_OFFSET]:s32, ptr
    
    call acquireMutex
    mul windowIndex, windowCount, 4
    allocSize size, windows
    gre cond, size, windowIndex
    jmpNZ skipResize, cond
    
    VAR newSize, s32
    mul newSize, size, 2
    newAlloc ptr, guardedAllocAttr, newSize
    wrtBuff ptr[0]:s8, windows[0]:s8, size
    delAlloc windows
    wrt windows, ptr
    
    LBL skipResize
    wrt windows[windowIndex]:s32, dest
    add windowCount, windowCount, 1
    wrt focusedWindow, dest
    call drawFocusedWindow
    releaseMutex
END

FUNC delWindow, wsDelWindow.id
    ARG window, s32
    callCheckPerm window
    
    VAR cond, s8
    VAR index, s32
    
    call acquireMutex
    wrt index, 0
    LBL findLoop
    equ cond, window, windows[index]:s32
    jmpNZ breakFind, cond
    add index, index, 4
    jmp findLoop
    
    LBL breakFind
    VAR nextIndex, s32
    add index, nextIndex, 4
    VAR size, s32
    allocSize size, windows
    VAR sizeToMove, s32
    sub sizeToMove, size, nextIndex
    wrtBuff windows[index]:s8, windows[nextIndex]:s8, sizeToMove
    sub index, size, 4
    wrt windows[index]:s8, null
    sub windowCount, windowCount, 1
    
    equ cond, window, focusedWindow
    jmpZ skipFocus, cond
    wrt focusedWindow, windows[0]:s32
    call drawFocusedWindow
    LBL skipFocus
    releaseMutex
    
    delAlloc window[title_OFFSET]:s32
    delAlloc window[termBuff_OFFSET]:s32
    # TODO: Clean up resources associated with current window mode.
    delAlloc window
END

FUNC displayWindowMessage, wsDisplayWindowMessage.id
    ARG dest, s8
    ARG window, s32
    ARG message, s32
    
    VAR verticalScroll, s32
    VAR cond, s8
    VAR index, s32
    
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    wrt verticalScroll, 0
    wrt window[mode_OFFSET]:s8, displayMessage_MODE
    
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s32, verticalScroll
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    LBL keyLoop
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    equ cond, key, 10
    jmpNZ enterPressed, cond
    equ cond, key, 27
    jmpNZ escapePressed, cond
    equ cond, key, -3
    jmpNZ upPressed, cond
    equ cond, key, -4
    jmpNZ downPressed, cond
    equ cond, key, 9
    jmpNZ tabPressed, cond
    equ cond, key, -5
    jmpNZ rtabPressed, cond
    jmp keyLoop
    
    LBL upPressed
    gre cond, verticalScroll, 0
    jmpZ keyLoop, cond
    sub verticalScroll, verticalScroll, 1
    jmp drawLoop
    
    LBL downPressed
    add index, verticalScroll, termHeight
    gre cond, window[messageLineAmount_OFFSET]:s32, index
    jmpZ keyLoop, cond
    add verticalScroll, verticalScroll, 1
    jmp drawLoop
    
    LBL tabPressed
    sub verticalScroll, window[messageLineAmount_OFFSET]:s32, termHeight
    gre cond, 0, verticalScroll
    jmpZ drawLoop, cond
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL rtabPressed
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL enterPressed
    wrt dest, 0
    jmp skipEscape
    LBL escapePressed
    wrt dest, 1
    LBL skipEscape
    wrt window[mode_OFFSET]:s8, none_MODE
END

FUNC promptWindowOption, wsPromptWindowOption.id
    ARG dest, s32
    ARG window, s32
    ARG message, s32
    ARG options, s32
    # TODO: Implement.
    
END

FUNC promptWindowText, wsPromptWindowText.id
    ARG dest, s32
    ARG window, s32
    ARG message, s32
    ARG startText, s32
    # TODO: Implement.
    
END

FUNC clrWindow, wsClrWindow.id
    ARG window, s32
    callCheckPerm window
    
    newArgFrame clrTermBuff.argsSize
    wrt clrTermBuff.args.termBuff, window[termBuff_OFFSET]:s32
    call clrTermBuff
    
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
END

FUNC windowTermSize, wsWindowTermSize.id
    ARG widthDest, s32
    ARG heightDest, s32
    ARG window, s32
    callCheckPerm window
    
    wrt widthDest, termWidth
    wrt heightDest, termHeight
END

FUNC readWindowTerm, wsReadWindowTerm.id
    ARG dest, s32
    ARG window, s32
    ARG x, s32
    ARG y, s32
    ARG length, s32
    callCheckPerm window
    
    VAR index, s32
    mul index, y, termWidth
    add index, index, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    newAlloc dest, 0, length
    setErrJmp cleanUpAlloc
    wrtBuff dest[0]:s8, termBuff[index]:s8, length
    ret
    
    LBL cleanUpAlloc
    delAlloc dest
    VAR err, s8
    err err
    throw err
END

FUNC wrtWindowTerm, wsWrtWindowTerm.id
    ARG window, s32
    ARG x, s32
    ARG y, s32
    ARG text, s32
    callCheckPerm window
    
    VAR index, s32
    mul index, y, termWidth
    add index, index, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    VAR size, s32
    allocSize size, text
    wrtBuff termBuff[index]:s8, text[0]:s8, size
    
    call acquireMutex
    VAR cond, s8
    equ cond, window, focusedWindow
    jmpZ skipDraw, cond
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.x, x
    wrt wsWrtTerm.args.y, y
    wrt wsWrtTerm.args.text, text
    callRemote termHandle, wrtTermIndex
    LBL skipDraw
    releaseMutex
END

APP_DATA
    LBL termNameStart
    DATA "wsTerm"
    LBL termNameEnd
    LBL testMessageStart
    DATA "Milk\nEggs\nSugar\nButter\nFlour\nVanilla\nChocolate\nBaking powder\nSalt\nVegetable oil\nMustard"
    LBL testMessageEnd
END


