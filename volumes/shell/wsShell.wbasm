
INCLUDE "../macros.wbasm"

MACRO callCheckPerm, window
    newArgFrame checkPerm.argsSize
    caller checkPerm.args.app
    wrt checkPerm.args.window, window
    call checkPerm
END

MACRO callCreateLine, dest, lineIndex, lines, lineCount
    newArgFrame createLine.argsSize
    wrt createLine.args.lines, lines
    wrt createLine.args.lineCount, lineCount
    call createLine
    wrt dest, createLine.args.dest
    wrt lines, createLine.args.lines
    wrt lineCount, createLine.args.lineCount
    wrt lineIndex, 0
END

MACRO updateCursorPosY
    div cursorPosY, cursorIndex, termWidth
    add cursorPosY, prevArg, messageLineAmount
    sub cursorPosY, prevArg, verticalScroll
END

DEF none_MODE, 0
DEF displayMessage_MODE, 1
DEF promptOption_MODE, 2
DEF promptText_MODE, 3

DEF owner_OFFSET, 0
DEF hasReqDel_OFFSET, 4
DEF title_OFFSET, 5
DEF mode_OFFSET, 9
DEF termBuff_OFFSET, 10
DEF verticalScroll_OFFSET, 14
DEF messageLines_OFFSET, 18
DEF messageLineAmount_OFFSET, 22
DEF input_OFFSET, 26
DEF inputLen_OFFSET, 30
DEF inputHorizontalScroll_OFFSET, 34
DEF inputCursorIndex_OFFSET, 38
DEF key_OFFSET, 42
DEF keyGate_OFFSET, 43
DEF ackGate_OFFSET, 47
DEF keyPressedIndex_OFFSET, 51
DEF focusChangedIndex_OFFSET, 55
DEF window_SIZE, 59

VAR thisApp, s32
# Must be acquired when accessing `windows`, `windowCount`, or `focusedWindow`.
VAR windowsMutex, s32
VAR windows, s32
VAR windowCount, s8
VAR focusedWindow, s32
VAR shellWindow, s32

VAR termHandle, s32
VAR wrtTermIndex, s32
VAR termWidth, s32
VAR termHeight, s32
VAR termBuffSize, s32
VAR emptyLine, s32

FUNC init, wsInit.id, guarded
    
    thisApp thisApp
    newGate windowsMutex, 1
    newAlloc windows, guardedAllocAttr, 20
    wrt windowCount, 0
    
    VAR termName, s32
    newTextAlloc termName, termNameStart, termNameEnd
    openFile termHandle, termName
    delAlloc termName
    launch termHandle
    findFunc wrtTermIndex, termHandle, wsWrtTerm.id
    VAR funcIndex, s32
    findFunc funcIndex, termHandle, wsTermSize.id
    newArgFrame wsTermSize.argsSize
    callRemote termHandle, funcIndex
    wrt termWidth, wsTermSize.args.widthDest
    wrt termHeight, wsTermSize.args.heightDest
    mul termBuffSize, termWidth, termHeight
    
    newAlloc emptyLine, guardedAllocAttr, termWidth
    fillBuff emptyLine[0]:s8, termWidth, 32:s8
    
    findFunc funcIndex, termHandle, wsListenTerm.id
    callRemote termHandle, funcIndex
    
    newArgFrame newWindow.argsSize
    call newWindow
    wrt shellWindow, newWindow.args.dest
    VAR testMessage, s32
    newTextAlloc testMessage, testMessage1Start, testMessage1End
    #VAR testOptions, s32
    #newAlloc testOptions, 0, 12
    #newTextAlloc testOptions[0]:s32, testOption1Start, testOption1End
    #newTextAlloc testOptions[4]:s32, testOption2Start, testOption2End
    #newTextAlloc testOptions[8]:s32, testOption3Start, testOption3End
    #newArgFrame promptWindowOption.argsSize
    #wrt promptWindowOption.args.window, shellWindow
    #wrt promptWindowOption.args.message, testMessage
    #wrt promptWindowOption.args.options, testOptions
    #call promptWindowOption
    newArgFrame promptWindowText.argsSize
    wrt promptWindowText.args.window, shellWindow
    wrt promptWindowText.args.message, testMessage
    wrt promptWindowText.args.startText, null
    call promptWindowText
    newArgFrame clrWindow.argsSize
    wrt clrWindow.args.window, shellWindow
    call clrWindow
END

FUNC termInput, wsTermInput.id, guarded
    ARG key, s8
    
    VAR window, s32
    wrt window, focusedWindow
    jmpNE openKeyGate, window[mode_OFFSET]:s8, none_MODE
    
    VAR keyPressedIndex, s32
    wrt keyPressedIndex, window[keyPressedIndex_OFFSET]:s32
    jmpG skipKeyPressed, 0, keyPressedIndex
    newArgFrame wsWindowKeyPressed.argsSize
    wrt wsWindowKeyPressed.args.window, window
    wrt wsWindowKeyPressed.args.key, key
    callRemote window[owner_OFFSET]:s32, keyPressedIndex
    LBL skipKeyPressed
    ret
    
    LBL openKeyGate
    VAR keyGate, s32
    wrt keyGate, window[keyGate_OFFSET]:s32
    openGate keyGate
    waitGate window[ackGate_OFFSET]:s32
    wrt window[key_OFFSET]:s8, key
    LBL resetLoop
    jmpE breakReset, window[mode_OFFSET]:s8, none_MODE
    jmpNZ resetLoop, window[key_OFFSET]:s8
    LBL breakReset
    closeGate keyGate
END

FUNC checkPerm, 0, guarded
    ARG app, s32
    ARG window, s32
    
    VAR cond, s8
    jmpE return, app, window[owner_OFFSET]:s32
    jmpE return, app, thisApp
    hasAdminPerm cond, app
    jmpNZ return, cond
    throw permErr
    LBL return
END

FUNC createLine, 0, guarded
    ARG dest, s32
    ARG lines, s32
    ARG lineCount, s32
    
    VAR index, s32
    VAR size, s32
    newAlloc dest, guardedAllocAttr, termWidth
    fillBuff dest[0]:s8, termWidth, 32:s8
    mul index, lineCount, 4
    allocSize size, lines
    jmpG skipResize, size, index
    
    VAR newSize, s32
    mul newSize, size, 2
    VAR newLines, s32
    newAlloc newLines, guardedAllocAttr, newSize
    wrtBuff newLines[0]:s8, lines[0]:s8, size
    delAlloc lines
    wrt lines, newLines
    
    LBL skipResize
    wrt lines[index]:s32, dest
    inc lineCount
END

FUNC splitMessage, 0, guarded
    ARG window, s32
    ARG message, s32
    
    VAR char, s8
    VAR size, s32
    
    jmpNZ skipNull, message
    wrt window[messageLineAmount_OFFSET]:s32, 0
    ret
    
    LBL skipNull
    VAR messageSize, s32
    VAR messageIndex, s32
    allocSize messageSize, message
    wrt messageIndex, 0
    
    VAR lines, s32
    VAR lineCount, s32
    VAR line, s32
    VAR lineIndex, s32
    newAlloc lines, guardedAllocAttr, 20
    wrt lineCount, 0
    callCreateLine line, lineIndex, lines, lineCount
    
    LBL splitLoop
    jmpNG breakSplit, messageSize, messageIndex
    
    VAR wordStartIndex, s32
    wrt wordStartIndex, messageIndex
    LBL spaceLoop
    jmpNG breakSpace, messageSize, wordStartIndex
    jmpNE breakSpace, message[wordStartIndex]:s8, 32
    inc wordStartIndex
    jmp spaceLoop
    LBL breakSpace
    
    VAR wordEndIndex, s32
    wrt wordEndIndex, wordStartIndex
    wrt size, 0
    LBL wordLoop
    jmpNG breakWord, messageSize, wordEndIndex
    jmpNG breakWord, termWidth, size
    wrt char, message[wordEndIndex]:s8
    jmpG breakWord, 33, char
    jmpG breakWord, char, 126
    inc wordEndIndex
    inc size
    jmpE breakWord, char, 45
    jmpNE wordLoop, char, 47
    LBL breakWord
    
    sub size, wordEndIndex, messageIndex
    VAR lineEndIndex, s32
    add lineEndIndex, lineIndex, size
    jmpNG skipCreateLine, lineEndIndex, termWidth
    
    callCreateLine line, lineIndex, lines, lineCount
    wrt messageIndex, wordStartIndex
    sub size, wordEndIndex, messageIndex
    
    LBL skipCreateLine
    wrtBuff line[lineIndex]:s8, message[messageIndex]:s8, size
    add lineIndex, prevArg, size
    wrt messageIndex, wordEndIndex
    
    LBL specialLoop
    jmpNG breakSpecial, messageSize, messageIndex
    wrt char, message[messageIndex]:s8
    jmpG breakSpecial, char, 31
    inc messageIndex
    jmpNE specialLoop, char, 10
    callCreateLine line, lineIndex, lines, lineCount
    jmp specialLoop
    LBL breakSpecial
    
    jmp splitLoop
    LBL breakSplit
    
    wrt window[messageLines_OFFSET]:s32, lines
    wrt window[messageLineAmount_OFFSET]:s32, lineCount
END

# Must be called with `windowsMutex`.
FUNC drawFocusedWindow, 0, guarded
    VAR index, s32
    VAR offset, s32
    VAR size, s32
    VAR ptr, s32
    VAR line, s32
    
    VAR mode, s8
    wrt mode, focusedWindow[mode_OFFSET]:s8
    jmpE noneMode, mode, none_MODE
    
    VAR posY, s32
    wrt posY, 0
    
    VAR verticalScroll, s32
    wrt verticalScroll, focusedWindow[verticalScroll_OFFSET]:s32
    
    VAR messageLines, s32
    VAR messageLineAmount, s32
    wrt messageLines, focusedWindow[messageLines_OFFSET]:s32
    wrt messageLineAmount, focusedWindow[messageLineAmount_OFFSET]:s32
    LBL messageLoop
    jmpNG stopDraw, termHeight, posY
    add index, verticalScroll, posY
    jmpNG breakMessage, messageLineAmount, index
    mul offset, index, 4
    wrt line, messageLines[offset]:s32
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    inc posY
    jmp messageLoop
    LBL breakMessage
    
    jmpE emptyLineLoop, mode, displayMessage_MODE
    
    VAR input, s32
    VAR inputLen, s32
    VAR cursorIndex, s32
    wrt input, focusedWindow[input_OFFSET]:s32
    wrt inputLen, focusedWindow[inputLen_OFFSET]:s32
    wrt cursorIndex, focusedWindow[inputCursorIndex_OFFSET]:s32
    
    add index, verticalScroll, posY
    sub index, prevArg, messageLineAmount
    jmpNG skipUnderflow, 0, index
    wrt index, 0
    LBL skipUnderflow
    newAlloc line, guardedAllocAttr, termWidth
    
    jmpE handlePromptText, mode, promptText_MODE
    
    VAR tempSize, s32
    sub tempSize, termWidth, 1
    LBL optionLoop
    jmpNG cleanUpLine, termHeight, posY
    jmpNG cleanUpLine, inputLen, index
    fillBuff line[0]:s8, termWidth, 32:s8
    mul offset, index, 4
    wrt ptr, input[offset]:s32
    allocSize size, ptr
    jmpE handleCursor, index, cursorIndex
    wrt offset, 0
    jmp skipCursor1
    LBL handleCursor
    wrt line[0]:s8, 62
    wrt offset, focusedWindow[inputHorizontalScroll_OFFSET]:s32
    LBL skipCursor1
    sub size, prevArg, offset
    jmpNG skipResize1, size, tempSize
    wrt size, tempSize
    LBL skipResize1
    wrtBuff line[1]:s8, ptr[offset]:s8, size
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    inc index
    inc posY
    jmp optionLoop
    
    LBL handlePromptText
    mul index, prevArg, termWidth
    LBL textLoop
    jmpNG cleanUpLine, termHeight, posY
    jmpG cleanUpLine, index, inputLen
    fillBuff line[0]:s8, termWidth, 32:s8
    sub size, inputLen, index
    jmpG skipText, 0, size
    jmpG skipResize2, termWidth, size
    wrt size, termWidth
    LBL skipResize2
    wrtBuff line[0]:s8, input[index]:s8, size
    LBL skipText
    sub offset, cursorIndex, index
    jmpG skipCursor2, 0, offset
    jmpNG skipCursor2, termWidth, offset
    wrt line[offset]:s8, 95
    LBL skipCursor2
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    add index, prevArg, termWidth
    inc posY
    jmp textLoop
    
    LBL cleanUpLine
    delAlloc line
    
    LBL emptyLineLoop
    jmpNG stopDraw, termHeight, posY
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, emptyLine
    callRemote termHandle, wrtTermIndex
    inc posY
    jmp emptyLineLoop
    
    LBL stopDraw
    ret
    
    LBL noneMode
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.text, focusedWindow[termBuff_OFFSET]:s32
    callRemote termHandle, wrtTermIndex
END

FUNC drawWindowIfFocused, 0, guarded
    ARG window, s32
    
    waitGate windowsMutex
    jmpNE skipDraw, window, focusedWindow
    call drawFocusedWindow
    LBL skipDraw
    openGate windowsMutex
END

FUNC focusWindow, 0, guarded
    ARG window, s32
    
    VAR lastWindow, s32
    VAR funcIndex, s32
    
    waitGate windowsMutex
    jmpE cancelFocus, window, focusedWindow
    wrt lastWindow, focusedWindow
    wrt focusedWindow, window
    call drawFocusedWindow
    openGate windowsMutex
    
    jmpZ skipBlur, lastWindow
    wrt funcIndex, lastWindow[focusChangedIndex_OFFSET]:s32
    jmpG skipBlur, 0, funcIndex
    newArgFrame wsWindowFocusChanged.argsSize
    wrt wsWindowFocusChanged.args.window, lastWindow
    wrt wsWindowFocusChanged.args.hasFocus, 0
    callRemote lastWindow[owner_OFFSET]:s32, funcIndex
    LBL skipBlur
    
    wrt funcIndex, window[focusChangedIndex_OFFSET]:s32
    jmpG skipFocus, 0, funcIndex
    newArgFrame wsWindowFocusChanged.argsSize
    wrt wsWindowFocusChanged.args.window, window
    wrt wsWindowFocusChanged.args.hasFocus, 1
    callRemote window[owner_OFFSET]:s32, funcIndex
    LBL skipFocus
    ret
    
    LBL cancelFocus
    openGate windowsMutex
END

FUNC waitForKey, 0, guarded
    ARG dest, s8
    ARG window, s32
    
    VAR ackGate, s32
    wrt ackGate, window[ackGate_OFFSET]:s32
    waitGate window[keyGate_OFFSET]:s32
    openGate ackGate
    LBL keyLoop
    wrt dest, window[key_OFFSET]:s8
    jmpZ keyLoop, dest
    closeGate ackGate
    wrt window[key_OFFSET]:s8, 0
END

FUNC newWindow, wsNewWindow.id
    ARG dest, s32
    ARG title, s32
    
    VAR windowIndex, s32
    VAR size, s32
    VAR ptr, s32
    
    newAlloc dest, guardedAllocAttr | sentryAllocAttr, window_SIZE
    caller ptr
    wrt dest[owner_OFFSET]:s32, ptr
    newGate dest[keyGate_OFFSET]:s32, 0
    newGate dest[ackGate_OFFSET]:s32, 0
    findFunc dest[keyPressedIndex_OFFSET]:s32, ptr, wsWindowKeyPressed.id
    findFunc dest[focusChangedIndex_OFFSET]:s32, ptr, wsWindowFocusChanged.id
    jmpNZ skipCreateTitle, title
    fileName title, ptr
    LBL skipCreateTitle
    wrt dest[title_OFFSET]:s32, title
    newAlloc ptr, guardedAllocAttr, termBuffSize
    fillBuff ptr[0]:s8, termBuffSize, 32:s8
    wrt dest[termBuff_OFFSET]:s32, ptr
    
    waitGate windowsMutex
    mul windowIndex, windowCount, 4
    allocSize size, windows
    jmpG skipResize, size, windowIndex
    
    VAR newSize, s32
    mul newSize, size, 2
    newAlloc ptr, guardedAllocAttr, newSize
    wrtBuff ptr[0]:s8, windows[0]:s8, size
    delAlloc windows
    wrt windows, ptr
    
    LBL skipResize
    wrt windows[windowIndex]:s32, dest
    inc windowCount
    openGate windowsMutex
    
    newArgFrame focusWindow.argsSize
    wrt focusWindow.args.window, dest
    call focusWindow
END

FUNC delWindow, wsDelWindow.id
    ARG window, s32
    callCheckPerm window
    
    VAR index, s32
    
    jmpNE skipFocus, window, focusedWindow
    waitGate windowsMutex
    wrt focusedWindow, null
    openGate windowsMutex
    newArgFrame focusWindow.argsSize
    wrt focusWindow.args.window, shellWindow
    call focusWindow
    LBL skipFocus
    
    waitGate windowsMutex
    wrt index, 0
    LBL findLoop
    jmpE breakFind, window, windows[index]:s32
    add index, prevArg, 4
    jmp findLoop
    
    LBL breakFind
    VAR nextIndex, s32
    add index, nextIndex, 4
    VAR size, s32
    allocSize size, windows
    VAR sizeToMove, s32
    sub sizeToMove, size, nextIndex
    wrtBuff windows[index]:s8, windows[nextIndex]:s8, sizeToMove
    sub index, size, 4
    wrt windows[index]:s8, null
    dec windowCount
    openGate windowsMutex
    
    delAlloc window[title_OFFSET]:s32
    delAlloc window[termBuff_OFFSET]:s32
    # TODO: Clean up resources associated with current window mode.
    delAlloc window
END

FUNC displayWindowMessage, wsDisplayWindowMessage.id
    ARG dest, s8
    ARG window, s32
    ARG message, s32
    
    VAR ackGate, s32
    VAR verticalScroll, s32
    VAR index, s32
    
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    wrt ackGate, window[ackGate_OFFSET]:s32
    wrt verticalScroll, 0
    wrt window[mode_OFFSET]:s8, displayMessage_MODE
    closeGate ackGate
    wrt window[key_OFFSET]:s8, 0
    
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s32, verticalScroll
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    LBL keyLoop
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    jmpE enterPressed, key, 10
    jmpE escapePressed, key, 27
    jmpE upPressed, key, -3
    jmpE downPressed, key, -4
    jmpE tabPressed, key, 9
    jmpE rtabPressed, key, -5
    jmp keyLoop
    
    LBL upPressed
    jmpNG keyLoop, verticalScroll, 0
    dec verticalScroll
    jmp drawLoop
    
    LBL downPressed
    add index, verticalScroll, termHeight
    jmpNG keyLoop, window[messageLineAmount_OFFSET]:s32, index
    inc verticalScroll
    jmp drawLoop
    
    LBL tabPressed
    sub verticalScroll, window[messageLineAmount_OFFSET]:s32, termHeight
    jmpNG drawLoop, 0, verticalScroll
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL rtabPressed
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL enterPressed
    wrt dest, 0
    jmp skipEscape
    LBL escapePressed
    wrt dest, 1
    LBL skipEscape
    wrt window[mode_OFFSET]:s8, none_MODE
    openGate ackGate
END

FUNC promptWindowOption, wsPromptWindowOption.id
    ARG dest, s32
    ARG window, s32
    ARG message, s32
    ARG options, s32
    
    VAR messageLineAmount, s32
    VAR ackGate, s32
    VAR verticalScroll, s32
    VAR horizontalScroll, s32
    VAR cursorIndex, s32
    VAR cursorPosY, s32
    VAR optionAmount, s32
    VAR totalLineAmount, s32
    VAR index, s32
    
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    wrt messageLineAmount, window[messageLineAmount_OFFSET]:s32
    
    wrt ackGate, window[ackGate_OFFSET]:s32
    wrt verticalScroll, 0
    wrt horizontalScroll, 0
    wrt cursorIndex, 0
    allocSize optionAmount, options
    div optionAmount, prevArg, 4
    add totalLineAmount, messageLineAmount, optionAmount
    wrt window[input_OFFSET]:s32, options
    wrt window[inputLen_OFFSET]:s32, optionAmount
    wrt window[mode_OFFSET]:s8, promptOption_MODE
    closeGate ackGate
    wrt window[key_OFFSET]:s8, 0
    
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s32, verticalScroll
    wrt window[inputHorizontalScroll_OFFSET]:s32, horizontalScroll
    wrt window[inputCursorIndex_OFFSET]:s32, cursorIndex
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    LBL keyLoop
    add cursorPosY, messageLineAmount, cursorIndex
    sub cursorPosY, prevArg, verticalScroll
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    jmpE enterPressed, key, 10
    jmpE escapePressed, key, 27
    jmpE upPressed, key, -3
    jmpE downPressed, key, -4
    jmpE leftPressed, key, -1
    jmpE rightPressed, key, -2
    jmpE tabPressed, key, 9
    jmpE rtabPressed, key, -5
    jmp keyLoop
    
    LBL upPressed
    jmpNG scroll1, cursorIndex, 0
    jmpG skipScroll1, cursorPosY, 0
    LBL scroll1
    dec verticalScroll
    LBL skipScroll1
    jmpNG skipCursor1, cursorIndex, 0
    jmpNG skipCursor1, termHeight, cursorPosY
    dec cursorIndex
    LBL skipCursor1
    jmp alignBounds
    
    LBL downPressed
    sub index, termHeight, 1
    jmpG skipScroll2, index, cursorPosY
    inc verticalScroll
    LBL skipScroll2
    sub index, optionAmount, 1
    jmpNG skipCursor2, index, cursorIndex
    jmpNG skipCursor2, termHeight, cursorPosY
    inc cursorIndex
    LBL skipCursor2
    jmp alignBounds
    
    LBL leftPressed
    sub horizontalScroll, prevArg, 4
    jmpNG drawLoop, 0, horizontalScroll
    wrt horizontalScroll, 0
    jmp drawLoop
    
    LBL rightPressed
    add horizontalScroll, prevArg, 4
    mul index, cursorIndex, 4
    allocSize index, options[index]:s32
    sub index, prevArg, termWidth
    inc index
    jmpNG drawLoop, horizontalScroll, index
    wrt horizontalScroll, index
    jmpNG drawLoop, 0, horizontalScroll
    wrt horizontalScroll, 0
    jmp drawLoop
    
    LBL tabPressed
    jmpG skipTab, termHeight, cursorPosY
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipTab
    sub verticalScroll, totalLineAmount, termHeight
    sub cursorIndex, optionAmount, 1
    jmp alignBounds
    
    LBL rtabPressed
    jmpNG skipRtab, cursorIndex, 0
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipRtab
    wrt verticalScroll, 0
    jmp alignBounds
    
    LBL alignBounds
    wrt horizontalScroll, 0
    sub index, totalLineAmount, termHeight
    jmpNG skipAlign, verticalScroll, index
    wrt verticalScroll, index
    LBL skipAlign
    jmpNG drawLoop, 0, verticalScroll
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL enterPressed
    jmpG acceptOption, termHeight, cursorPosY
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL acceptOption
    wrt dest, cursorIndex
    jmp skipEscape
    LBL escapePressed
    wrt dest, -1
    LBL skipEscape
    wrt window[mode_OFFSET]:s8, none_MODE
    openGate ackGate
END

FUNC promptWindowText, wsPromptWindowText.id
    ARG dest, s32
    ARG window, s32
    ARG message, s32
    ARG startText, s32
    
    VAR messageLineAmount, s32
    VAR ackGate, s32
    VAR verticalScroll, s32
    VAR inputText, s32
    VAR inputTextLen, s32
    VAR cursorIndex, s32
    VAR cursorPosY, s32
    VAR index, s32
    VAR size, s32
    VAR ptr, s32
    
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    wrt messageLineAmount, window[messageLineAmount_OFFSET]:s32
    
    jmpNZ handleStartText, startText
    wrt inputTextLen, 0
    newAlloc inputText, guardedAllocAttr, 10
    wrt cursorIndex, 0
    jmp skipStartText
    LBL handleStartText
    allocSize inputTextLen, startText
    add size, inputTextLen, 10
    newAlloc inputText, guardedAllocAttr, size
    wrtBuff inputText[0]:s8, startText[0]:s8, inputTextLen
    wrt cursorIndex, inputTextLen
    LBL skipStartText
    
    wrt ackGate, window[ackGate_OFFSET]:s32
    wrt verticalScroll, 0
    wrt window[input_OFFSET]:s32, inputText
    wrt window[inputLen_OFFSET]:s32, inputTextLen
    wrt window[mode_OFFSET]:s8, promptText_MODE
    closeGate ackGate
    wrt window[key_OFFSET]:s8, 0
    
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s32, verticalScroll
    wrt window[inputLen_OFFSET]:s32, inputTextLen
    wrt window[inputCursorIndex_OFFSET]:s32, cursorIndex
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    LBL keyLoop
    updateCursorPosY
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    jmpE deletePressed, key, 127
    jmpG charPressed, key, 31
    jmpE enterPressed, key, 10
    jmpE escapePressed, key, 27
    jmpE upPressed, key, -3
    jmpE downPressed, key, -4
    jmpE leftPressed, key, -1
    jmpE rightPressed, key, -2
    jmpE tabPressed, key, 9
    jmpE rtabPressed, key, -5
    jmp keyLoop
    
    LBL deletePressed
    jmpNG keyLoop, cursorIndex, 0
    sub index, cursorIndex, 1
    sub size, inputTextLen, cursorIndex
    jmpNG skipCopy1, size, 0
    wrtBuff inputText[index]:s8, inputText[cursorIndex]:s8, size
    LBL skipCopy1
    wrt cursorIndex, index
    dec inputTextLen
    jmp scrollToCursor
    
    LBL charPressed
    allocSize size, inputText
    jmpG skipResize, size, inputTextLen
    VAR newSize, s32
    mul newSize, size, 2
    newAlloc ptr, guardedAllocAttr, newSize
    wrtBuff ptr[0]:s8, inputText[0]:s8, size
    delAlloc inputText
    wrt inputText, ptr
    wrt window[input_OFFSET]:s32, inputText
    LBL skipResize
    add index, cursorIndex, 1
    sub size, inputTextLen, cursorIndex
    jmpNG skipCopy2, size, 0
    wrtBuff inputText[index]:s8, inputText[cursorIndex]:s8, size
    LBL skipCopy2
    wrt inputText[cursorIndex]:s8, key
    wrt cursorIndex, index
    inc inputTextLen
    jmp scrollToCursor
    
    LBL upPressed
    jmpZ scrollUp, cursorIndex
    jmpG moveCursorUp, termHeight, cursorPosY
    LBL scrollUp
    dec verticalScroll
    jmp alignBounds
    LBL moveCursorUp
    sub cursorIndex, prevArg, termWidth
    jmpNG scrollToCursor, 0, cursorIndex
    wrt cursorIndex, 0
    jmp scrollToCursor
    
    LBL downPressed
    jmpG moveCursorDown, termHeight, cursorPosY
    inc verticalScroll
    jmp alignBounds
    LBL moveCursorDown
    add cursorIndex, prevArg, termWidth
    jmpNG scrollToCursor, cursorIndex, inputTextLen
    wrt cursorIndex, inputTextLen
    jmp scrollToCursor
    
    LBL leftPressed
    jmpNG keyLoop, cursorIndex, 0
    dec cursorIndex
    jmp scrollToCursor
    
    LBL rightPressed
    jmpNG keyLoop, inputTextLen, cursorIndex
    inc cursorIndex
    jmp scrollToCursor
    
    LBL tabPressed
    jmpG skipTab, termHeight, cursorPosY
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipTab
    div verticalScroll, inputTextLen, termWidth
    add verticalScroll, prevArg, messageLineAmount
    wrt cursorIndex, inputTextLen
    jmp alignBounds
    
    LBL rtabPressed
    jmpNG skipRtab, cursorIndex, 0
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipRtab
    wrt verticalScroll, 0
    jmp alignBounds
    
    LBL scrollToCursor
    updateCursorPosY
    jmpNG skipScrollBack, 0, cursorPosY
    div verticalScroll, cursorIndex, termWidth
    add verticalScroll, prevArg, messageLineAmount
    jmp alignBounds
    LBL skipScrollBack
    jmpG alignBounds, termHeight, cursorPosY
    div verticalScroll, cursorIndex, termWidth
    add verticalScroll, prevArg, messageLineAmount
    sub verticalScroll, prevArg, termHeight
    inc verticalScroll
    
    LBL alignBounds
    VAR totalLineAmount, s32
    div totalLineAmount, inputTextLen, termWidth
    inc totalLineAmount
    add totalLineAmount, prevArg, messageLineAmount
    sub index, totalLineAmount, termHeight
    jmpNG skipAlign, verticalScroll, index
    wrt verticalScroll, index
    LBL skipAlign
    jmpNG drawLoop, 0, verticalScroll
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL enterPressed
    jmpG acceptText, termHeight, cursorPosY
    wrt cursorIndex, inputTextLen
    jmp scrollToCursor
    LBL acceptText
    newAlloc dest, 0, inputTextLen
    jmpZ skipEscape, inputTextLen
    wrtBuff dest[0]:s8, inputText[0]:s8, inputTextLen
    jmp skipEscape
    LBL escapePressed
    wrt dest, null
    LBL skipEscape
    wrt window[mode_OFFSET]:s8, none_MODE
    openGate ackGate
END

FUNC clrWindow, wsClrWindow.id
    ARG window, s32
    callCheckPerm window
    
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    fillBuff termBuff[0]:s8, termBuffSize, 32:s8
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
END

FUNC windowTermSize, wsWindowTermSize.id
    ARG widthDest, s32
    ARG heightDest, s32
    ARG window, s32
    callCheckPerm window
    
    wrt widthDest, termWidth
    wrt heightDest, termHeight
END

FUNC readWindowTerm, wsReadWindowTerm.id
    ARG dest, s32
    ARG window, s32
    ARG x, s32
    ARG y, s32
    ARG length, s32
    callCheckPerm window
    
    VAR index, s32
    mul index, y, termWidth
    add index, prevArg, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    newAlloc dest, 0, length
    setErrJmp cleanUpAlloc
    wrtBuff dest[0]:s8, termBuff[index]:s8, length
    ret
    
    LBL cleanUpAlloc
    delAlloc dest
    VAR err, s8
    err err
    throw err
END

FUNC wrtWindowTerm, wsWrtWindowTerm.id
    ARG window, s32
    ARG x, s32
    ARG y, s32
    ARG text, s32
    callCheckPerm window
    
    VAR index, s32
    mul index, y, termWidth
    add index, prevArg, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    VAR size, s32
    allocSize size, text
    wrtBuff termBuff[index]:s8, text[0]:s8, size
    
    waitGate windowsMutex
    jmpNE skipDraw, window, focusedWindow
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.x, x
    wrt wsWrtTerm.args.y, y
    wrt wsWrtTerm.args.text, text
    callRemote termHandle, wrtTermIndex
    LBL skipDraw
    openGate windowsMutex
END

APP_DATA
    LBL termNameStart
    DATA "wsTerm"
    LBL termNameEnd
    LBL testMessage1Start
    DATA "Milk\nEggs\nSugar\nButter\nFlour\nVanilla\nChocolate\nBaking powder\nSalt\nVegetable oil\nMustard"
    LBL testMessage1End
    LBL testMessage2Start
    DATA "Enter some text:"
    LBL testMessage2End
    LBL testOption1Start
    DATA "Buy"
    LBL testOption1End
    LBL testOption2Start
    DATA "This is a really long option which requires horizontal scroll"
    LBL testOption2End
    LBL testOption3Start
    DATA "Sell"
    LBL testOption3End
END


