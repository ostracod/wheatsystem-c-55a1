
INCLUDE "../macros.wbasm"

MACRO releaseMutex
    wrt mutexFlag, 0
END

MACRO callCheckPerm, window
    newArgFrame checkPerm.argsSize
    caller checkPerm.args.app
    wrt checkPerm.args.window, window
    call checkPerm
END

MACRO callCreateLine, dest, lineIndex, lines, lineCount
    newArgFrame createLine.argsSize
    wrt createLine.args.lines, lines
    wrt createLine.args.lineCount, lineCount
    call createLine
    wrt dest, createLine.args.dest
    wrt lines, createLine.args.lines
    wrt lineCount, createLine.args.lineCount
    wrt lineIndex, 0
END

DEF none_MODE, 0
DEF displayMessage_MODE, 1
DEF promptOption_MODE, 2
DEF promptText_MODE, 3

DEF owner_OFFSET, 0
DEF hasReqDel_OFFSET, 4
DEF title_OFFSET, 5
DEF mode_OFFSET, 9
DEF termBuff_OFFSET, 10
DEF verticalScroll_OFFSET, 14
DEF messageLines_OFFSET, 18
DEF messageLineAmount_OFFSET, 22
DEF input_OFFSET, 26
DEF inputLen_OFFSET, 30
DEF inputHorizontalScroll_OFFSET, 34
DEF inputCursorIndex_OFFSET, 38
DEF key_OFFSET, 42
DEF keyPressedIndex_OFFSET, 43
DEF window_SIZE, 47

VAR thisApp, s32
VAR mutexFlag, s8
VAR windows, s32
VAR windowCount, s8
VAR focusedWindow, s32
VAR shellWindow, s32

VAR termHandle, s32
VAR wrtTermIndex, s32
VAR termWidth, s32
VAR termHeight, s32
VAR termBuffSize, s32
VAR emptyLine, s32

FUNC init, wsInit.id, guarded
    
    thisApp thisApp
    wrt mutexFlag, 0
    newAlloc windows, guardedAllocAttr, 20
    wrt windowCount, 0
    
    VAR termName, s32
    newTextAlloc termName, termNameStart, termNameEnd
    openFile termHandle, termName
    delAlloc termName
    launch termHandle
    findFunc wrtTermIndex, termHandle, wsWrtTerm.id
    VAR funcIndex, s32
    findFunc funcIndex, termHandle, wsTermSize.id
    newArgFrame wsTermSize.argsSize
    callRemote termHandle, funcIndex
    wrt termWidth, wsTermSize.args.widthDest
    wrt termHeight, wsTermSize.args.heightDest
    mul termBuffSize, termWidth, termHeight
    
    newAlloc emptyLine, guardedAllocAttr, termWidth
    VAR cond, s8
    VAR index, s32
    wrt index, 0
    LBL emptyLineLoop
    wrt emptyLine[index]:s8, 32
    add index, index, 1
    gre cond, termWidth, index
    jmpNZ emptyLineLoop, cond
    
    findFunc funcIndex, termHandle, wsListenTerm.id
    callRemote termHandle, funcIndex
    
    newArgFrame newWindow.argsSize
    call newWindow
    wrt shellWindow, newWindow.args.dest
    VAR testMessage, s32
    newTextAlloc testMessage, testMessage1Start, testMessage1End
    VAR testOptions, s32
    newAlloc testOptions, 0, 12
    newTextAlloc testOptions[0]:s32, testOption1Start, testOption1End
    newTextAlloc testOptions[4]:s32, testOption2Start, testOption2End
    newTextAlloc testOptions[8]:s32, testOption3Start, testOption3End
    newArgFrame promptWindowOption.argsSize
    wrt promptWindowOption.args.window, shellWindow
    wrt promptWindowOption.args.message, testMessage
    wrt promptWindowOption.args.options, testOptions
    call promptWindowOption
    newArgFrame clrWindow.argsSize
    wrt clrWindow.args.window, shellWindow
    call clrWindow
END

FUNC termInput, wsTermInput.id, guarded
    ARG key, s8
    
    VAR cond, s8
    
    VAR window, s32
    wrt window, focusedWindow
    equ cond, window[mode_OFFSET]:s8, none_MODE
    jmpZ resumeWithKey, cond
    
    VAR keyPressedIndex, s32
    wrt keyPressedIndex, window[keyPressedIndex_OFFSET]:s32
    jmpZ skipKeyPressed, keyPressedIndex
    newArgFrame wsWindowKeyPressed.argsSize
    wrt wsWindowKeyPressed.args.window, window
    wrt wsWindowKeyPressed.args.key, key
    callRemote window[owner_OFFSET]:s32, keyPressedIndex
    LBL skipKeyPressed
    ret
    
    LBL resumeWithKey
    wrt window[key_OFFSET]:s8, key
    LBL resumeLoop
    resume
    jmpZ breakResume, window[key_OFFSET]:s8
    equ cond, window[mode_OFFSET]:s8, none_MODE
    jmpZ resumeLoop, cond
    wrt window[key_OFFSET]:s8, 0
    LBL breakResume
END

# Must be called when accessing `windows`, `windowCount`, or `focusedWindow`.
FUNC acquireMutex, 0, guarded
    VAR oldValue, s8
    LBL loop
    testAndSet oldValue, mutexFlag
    jmpNZ loop, oldValue
END

FUNC checkPerm, 0, guarded
    ARG app, s32
    ARG window, s32
    
    VAR cond, s8
    equ cond, app, window[owner_OFFSET]:s32
    jmpNZ return, cond
    equ cond, app, thisApp
    jmpNZ return, cond
    hasAdminPerm cond, app
    jmpNZ return, cond
    throw permErr
    LBL return
END

FUNC clrTermBuff, 0, guarded
    ARG termBuff, s32
    
    VAR cond, s8
    VAR index, s32
    wrt index, 0
    LBL loop
    wrt termBuff[index]:s8, 32
    add index, index, 1
    gre cond, termBuffSize, index
    jmpNZ loop, cond
END

FUNC createLine, 0, guarded
    ARG dest, s32
    ARG lines, s32
    ARG lineCount, s32
    
    VAR index, s32
    VAR size, s32
    newAlloc dest, guardedAllocAttr, termWidth
    wrtBuff dest[0]:s8, emptyLine[0]:s8, termWidth
    mul index, lineCount, 4
    allocSize size, lines
    VAR cond, s8
    gre cond, size, index
    jmpNZ skipResize, cond
    
    VAR newSize, s32
    mul newSize, size, 2
    VAR newLines, s32
    newAlloc newLines, guardedAllocAttr, newSize
    wrtBuff newLines[0]:s8, lines[0]:s8, size
    delAlloc lines
    wrt lines, newLines
    
    LBL skipResize
    wrt lines[index]:s32, dest
    add lineCount, lineCount, 1
END

FUNC splitMessage, 0, guarded
    ARG window, s32
    ARG message, s32
    
    VAR cond, s8
    VAR char, s8
    
    VAR messageSize, s32
    VAR messageIndex, s32
    allocSize messageSize, message
    wrt messageIndex, 0
    
    VAR lines, s32
    VAR lineCount, s32
    VAR line, s32
    VAR lineIndex, s32
    newAlloc lines, guardedAllocAttr, 20
    wrt lineCount, 0
    callCreateLine line, lineIndex, lines, lineCount
    
    LBL splitLoop
    gre cond, messageSize, messageIndex
    jmpZ breakSplit, cond
    
    VAR wordStartIndex, s32
    wrt wordStartIndex, messageIndex
    LBL spaceLoop
    gre cond, messageSize, wordStartIndex
    jmpZ breakSpace, cond
    equ cond, message[wordStartIndex]:s8, 32
    jmpZ breakSpace, cond
    add wordStartIndex, wordStartIndex, 1
    jmp spaceLoop
    LBL breakSpace
    
    VAR wordEndIndex, s32
    wrt wordEndIndex, wordStartIndex
    LBL wordLoop
    gre cond, messageSize, wordEndIndex
    jmpZ breakWord, cond
    wrt char, message[wordEndIndex]:s8
    gre cond, 33, char
    jmpNZ breakWord, cond
    gre cond, char, 126
    jmpNZ breakWord, cond
    add wordEndIndex, wordEndIndex, 1
    equ cond, char, 45
    jmpNZ breakWord, cond
    equ cond, char, 47
    jmpZ wordLoop, cond
    LBL breakWord
    
    VAR size, s32
    sub size, wordEndIndex, messageIndex
    VAR lineEndIndex, s32
    add lineEndIndex, lineIndex, size
    gre cond, lineEndIndex, termWidth
    jmpZ skipCreateLine, cond
    
    callCreateLine line, lineIndex, lines, lineCount
    wrt messageIndex, wordStartIndex
    sub size, wordEndIndex, messageIndex
    
    LBL skipCreateLine
    wrtBuff line[lineIndex]:s8, message[messageIndex]:s8, size
    add lineIndex, lineIndex, size
    wrt messageIndex, wordEndIndex
    
    LBL specialLoop
    gre cond, messageSize, messageIndex
    jmpZ breakSpecial, cond
    wrt char, message[messageIndex]:s8
    gre cond, char, 31
    jmpNZ breakSpecial, cond
    add messageIndex, messageIndex, 1
    equ cond, char, 10
    jmpZ specialLoop, cond
    callCreateLine line, lineIndex, lines, lineCount
    jmp specialLoop
    LBL breakSpecial
    
    jmp splitLoop
    LBL breakSplit
    
    wrt window[messageLines_OFFSET]:s32, lines
    wrt window[messageLineAmount_OFFSET]:s32, lineCount
END

# Must be called between `acquireMutex` and `releaseMutex`.
FUNC drawFocusedWindow, 0, guarded
    VAR cond, s8
    VAR index, s32
    VAR offset, s32
    VAR size, s32
    VAR ptr, s32
    VAR line, s32
    
    VAR mode, s8
    wrt mode, focusedWindow[mode_OFFSET]:s8
    equ cond, mode, none_MODE
    jmpNZ noneMode, cond
    
    VAR posY, s32
    wrt posY, 0
    
    VAR verticalScroll, s32
    wrt verticalScroll, focusedWindow[verticalScroll_OFFSET]:s32
    
    VAR messageLines, s32
    VAR messageLineAmount, s32
    wrt messageLines, focusedWindow[messageLines_OFFSET]:s32
    wrt messageLineAmount, focusedWindow[messageLineAmount_OFFSET]:s32
    LBL messageLoop
    gre cond, termHeight, posY
    jmpZ stopDraw, cond
    add index, verticalScroll, posY
    gre cond, messageLineAmount, index
    jmpZ breakMessage, cond
    mul offset, index, 4
    wrt line, messageLines[offset]:s32
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    add posY, posY, 1
    jmp messageLoop
    LBL breakMessage
    
    equ cond, mode, displayMessage_MODE
    jmpNZ emptyLineLoop, cond
    
    VAR input, s32
    VAR inputLen, s32
    VAR cursorIndex, s32
    wrt input, focusedWindow[input_OFFSET]:s32
    wrt inputLen, focusedWindow[inputLen_OFFSET]:s32
    wrt cursorIndex, focusedWindow[inputCursorIndex_OFFSET]:s32
    
    VAR tempSize, s32
    sub tempSize, termWidth, 1
    add index, verticalScroll, posY
    sub index, index, messageLineAmount
    gre cond, 0, index
    jmpZ skipUnderflow, cond
    wrt index, 0
    LBL skipUnderflow
    newAlloc line, guardedAllocAttr, termWidth
    LBL optionLoop
    gre cond, termHeight, posY
    jmpZ stopDraw, cond
    gre cond, inputLen, index
    jmpZ breakOption, cond
    wrtBuff line[0]:s8, emptyLine[0]:s8, termWidth
    mul offset, index, 4
    wrt ptr, input[offset]:s32
    allocSize size, ptr
    equ cond, index, cursorIndex
    jmpNZ handleCursor, cond
    wrt offset, 0
    jmp skipCursor
    LBL handleCursor
    wrt line[0]:s8, 62
    wrt offset, focusedWindow[inputHorizontalScroll_OFFSET]:s32
    LBL skipCursor
    sub size, size, offset
    gre cond, size, tempSize
    jmpZ skipResize, cond
    wrt size, tempSize
    LBL skipResize
    wrtBuff line[1]:s8, ptr[offset]:s8, size
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, line
    callRemote termHandle, wrtTermIndex
    add index, index, 1
    add posY, posY, 1
    jmp optionLoop
    LBL breakOption
    delAlloc line
    
    LBL emptyLineLoop
    gre cond, termHeight, posY
    jmpZ stopDraw, cond
    wrt wsWrtTerm.args.y, posY
    wrt wsWrtTerm.args.text, emptyLine
    callRemote termHandle, wrtTermIndex
    add posY, posY, 1
    jmp emptyLineLoop
    
    LBL stopDraw
    ret
    
    LBL noneMode
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.text, focusedWindow[termBuff_OFFSET]:s32
    callRemote termHandle, wrtTermIndex
END

FUNC drawWindowIfFocused, 0, guarded
    ARG window, s32
    
    call acquireMutex
    VAR cond, s8
    equ cond, window, focusedWindow
    jmpZ skipDraw, cond
    call drawFocusedWindow
    LBL skipDraw
    releaseMutex
END

FUNC waitForKey, 0, guarded
    ARG dest, s8
    ARG window, s32
    
    LBL waitLoop
    wait
    wrt dest, window[key_OFFSET]:s8
    jmpZ waitLoop, dest
    
    wrt window[key_OFFSET]:s8, 0
END

FUNC newWindow, wsNewWindow.id
    ARG dest, s32
    ARG title, s32
    
    VAR windowIndex, s32
    VAR size, s32
    VAR cond, s8
    VAR ptr, s32
    
    newAlloc dest, guardedAllocAttr | sentryAllocAttr, window_SIZE
    caller ptr
    wrt dest[owner_OFFSET]:s32, ptr
    findFunc dest[keyPressedIndex_OFFSET]:s32, ptr, wsWindowKeyPressed.id
    jmpNZ skipCreateTitle, title
    fileName title, ptr
    LBL skipCreateTitle
    wrt dest[title_OFFSET]:s32, title
    newAlloc ptr, guardedAllocAttr, termBuffSize
    newArgFrame clrTermBuff.argsSize
    wrt clrTermBuff.args.termBuff, ptr
    call clrTermBuff
    wrt dest[termBuff_OFFSET]:s32, ptr
    
    call acquireMutex
    mul windowIndex, windowCount, 4
    allocSize size, windows
    gre cond, size, windowIndex
    jmpNZ skipResize, cond
    
    VAR newSize, s32
    mul newSize, size, 2
    newAlloc ptr, guardedAllocAttr, newSize
    wrtBuff ptr[0]:s8, windows[0]:s8, size
    delAlloc windows
    wrt windows, ptr
    
    LBL skipResize
    wrt windows[windowIndex]:s32, dest
    add windowCount, windowCount, 1
    wrt focusedWindow, dest
    call drawFocusedWindow
    releaseMutex
END

FUNC delWindow, wsDelWindow.id
    ARG window, s32
    callCheckPerm window
    
    VAR cond, s8
    VAR index, s32
    
    call acquireMutex
    wrt index, 0
    LBL findLoop
    equ cond, window, windows[index]:s32
    jmpNZ breakFind, cond
    add index, index, 4
    jmp findLoop
    
    LBL breakFind
    VAR nextIndex, s32
    add index, nextIndex, 4
    VAR size, s32
    allocSize size, windows
    VAR sizeToMove, s32
    sub sizeToMove, size, nextIndex
    wrtBuff windows[index]:s8, windows[nextIndex]:s8, sizeToMove
    sub index, size, 4
    wrt windows[index]:s8, null
    sub windowCount, windowCount, 1
    
    equ cond, window, focusedWindow
    jmpZ skipFocus, cond
    wrt focusedWindow, windows[0]:s32
    call drawFocusedWindow
    LBL skipFocus
    releaseMutex
    
    delAlloc window[title_OFFSET]:s32
    delAlloc window[termBuff_OFFSET]:s32
    # TODO: Clean up resources associated with current window mode.
    delAlloc window
END

FUNC displayWindowMessage, wsDisplayWindowMessage.id
    ARG dest, s8
    ARG window, s32
    ARG message, s32
    
    VAR verticalScroll, s32
    VAR cond, s8
    VAR index, s32
    
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    wrt verticalScroll, 0
    wrt window[mode_OFFSET]:s8, displayMessage_MODE
    
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s32, verticalScroll
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    LBL keyLoop
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    equ cond, key, 10
    jmpNZ enterPressed, cond
    equ cond, key, 27
    jmpNZ escapePressed, cond
    equ cond, key, -3
    jmpNZ upPressed, cond
    equ cond, key, -4
    jmpNZ downPressed, cond
    equ cond, key, 9
    jmpNZ tabPressed, cond
    equ cond, key, -5
    jmpNZ rtabPressed, cond
    jmp keyLoop
    
    LBL upPressed
    gre cond, verticalScroll, 0
    jmpZ keyLoop, cond
    sub verticalScroll, verticalScroll, 1
    jmp drawLoop
    
    LBL downPressed
    add index, verticalScroll, termHeight
    gre cond, window[messageLineAmount_OFFSET]:s32, index
    jmpZ keyLoop, cond
    add verticalScroll, verticalScroll, 1
    jmp drawLoop
    
    LBL tabPressed
    sub verticalScroll, window[messageLineAmount_OFFSET]:s32, termHeight
    gre cond, 0, verticalScroll
    jmpZ drawLoop, cond
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL rtabPressed
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL enterPressed
    wrt dest, 0
    jmp skipEscape
    LBL escapePressed
    wrt dest, 1
    LBL skipEscape
    wrt window[mode_OFFSET]:s8, none_MODE
END

FUNC promptWindowOption, wsPromptWindowOption.id
    ARG dest, s32
    ARG window, s32
    ARG message, s32
    ARG options, s32
    
    VAR messageLineAmount, s32
    VAR verticalScroll, s32
    VAR horizontalScroll, s32
    VAR cursorIndex, s32
    VAR cursorPosY, s32
    VAR optionAmount, s32
    VAR totalLineAmount, s32
    VAR cond, s32
    VAR index, s32
    
    jmpNZ handleMessage, message
    wrt messageLineAmount, 0
    wrt window[messageLineAmount_OFFSET]:s32, messageLineAmount
    jmp skipMessage
    
    LBL handleMessage
    newArgFrame splitMessage.argsSize
    wrt splitMessage.args.window, window
    wrt splitMessage.args.message, message
    call splitMessage
    wrt messageLineAmount, window[messageLineAmount_OFFSET]:s32
    
    LBL skipMessage
    wrt verticalScroll, 0
    wrt horizontalScroll, 0
    wrt cursorIndex, 0
    allocSize optionAmount, options
    div optionAmount, optionAmount, 4
    add totalLineAmount, messageLineAmount, optionAmount
    wrt window[input_OFFSET]:s32, options
    wrt window[inputLen_OFFSET]:s32, optionAmount
    wrt window[mode_OFFSET]:s8, promptOption_MODE
    
    LBL drawLoop
    wrt window[verticalScroll_OFFSET]:s32, verticalScroll
    wrt window[inputHorizontalScroll_OFFSET]:s32, horizontalScroll
    wrt window[inputCursorIndex_OFFSET]:s32, cursorIndex
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
    
    LBL keyLoop
    newArgFrame waitForKey.argsSize
    wrt waitForKey.args.window, window
    call waitForKey
    VAR key, s8
    wrt key, waitForKey.args.dest
    add cursorPosY, messageLineAmount, cursorIndex
    sub cursorPosY, cursorPosY, verticalScroll
    equ cond, key, 10
    jmpNZ enterPressed, cond
    equ cond, key, 27
    jmpNZ escapePressed, cond
    equ cond, key, -3
    jmpNZ upPressed, cond
    equ cond, key, -4
    jmpNZ downPressed, cond
    equ cond, key, -1
    jmpNZ leftPressed, cond
    equ cond, key, -2
    jmpNZ rightPressed, cond
    equ cond, key, 9
    jmpNZ tabPressed, cond
    equ cond, key, -5
    jmpNZ rtabPressed, cond
    jmp keyLoop
    
    LBL upPressed
    gre cond, cursorIndex, 0
    jmpZ scroll1, cond
    gre cond, cursorPosY, 0
    jmpNZ skipScroll1, cond
    LBL scroll1
    sub verticalScroll, verticalScroll, 1
    LBL skipScroll1
    gre cond, cursorIndex, 0
    jmpZ skipCursor1, cond
    gre cond, termHeight, cursorPosY
    jmpZ skipCursor1, cond
    sub cursorIndex, cursorIndex, 1
    LBL skipCursor1
    jmp alignBounds
    
    LBL downPressed
    sub index, termHeight, 1
    gre cond, index, cursorPosY
    jmpNZ skipScroll2, cond
    add verticalScroll, verticalScroll, 1
    LBL skipScroll2
    sub index, optionAmount, 1
    gre cond, index, cursorIndex
    jmpZ skipCursor2, cond
    gre cond, termHeight, cursorPosY
    jmpZ skipCursor2, cond
    add cursorIndex, cursorIndex, 1
    LBL skipCursor2
    jmp alignBounds
    
    LBL leftPressed
    sub horizontalScroll, horizontalScroll, 4
    gre cond, 0, horizontalScroll
    jmpZ drawLoop, cond
    wrt horizontalScroll, 0
    jmp drawLoop
    
    LBL rightPressed
    add horizontalScroll, horizontalScroll, 4
    mul index, cursorIndex, 4
    allocSize index, options[index]:s32
    sub index, index, termWidth
    add index, index, 1
    gre cond, horizontalScroll, index
    jmpZ drawLoop, cond
    wrt horizontalScroll, index
    gre cond, 0, horizontalScroll
    jmpZ drawLoop, cond
    wrt horizontalScroll, 0
    jmp drawLoop
    
    LBL tabPressed
    gre cond, termHeight, cursorPosY
    jmpNZ skipTab, cond
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipTab
    sub verticalScroll, totalLineAmount, termHeight
    sub cursorIndex, optionAmount, 1
    jmp alignBounds
    
    LBL rtabPressed
    gre cond, cursorIndex, 0
    jmpZ skipRtab, cond
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL skipRtab
    wrt verticalScroll, 0
    jmp alignBounds
    
    LBL alignBounds
    wrt horizontalScroll, 0
    sub index, totalLineAmount, termHeight
    gre cond, verticalScroll, index
    jmpZ skipAlign, cond
    wrt verticalScroll, index
    LBL skipAlign
    gre cond, 0, verticalScroll
    jmpZ drawLoop, cond
    wrt verticalScroll, 0
    jmp drawLoop
    
    LBL enterPressed
    gre cond, termHeight, cursorPosY
    jmpNZ acceptOption, cond
    wrt verticalScroll, messageLineAmount
    wrt cursorIndex, 0
    jmp alignBounds
    LBL acceptOption
    wrt dest, cursorIndex
    jmp skipEscape
    LBL escapePressed
    wrt dest, -1
    LBL skipEscape
    wrt window[mode_OFFSET]:s8, none_MODE
END

FUNC promptWindowText, wsPromptWindowText.id
    ARG dest, s32
    ARG window, s32
    ARG message, s32
    ARG startText, s32
    # TODO: Implement.
    
END

FUNC clrWindow, wsClrWindow.id
    ARG window, s32
    callCheckPerm window
    
    newArgFrame clrTermBuff.argsSize
    wrt clrTermBuff.args.termBuff, window[termBuff_OFFSET]:s32
    call clrTermBuff
    
    newArgFrame drawWindowIfFocused.argsSize
    wrt drawWindowIfFocused.args.window, window
    call drawWindowIfFocused
END

FUNC windowTermSize, wsWindowTermSize.id
    ARG widthDest, s32
    ARG heightDest, s32
    ARG window, s32
    callCheckPerm window
    
    wrt widthDest, termWidth
    wrt heightDest, termHeight
END

FUNC readWindowTerm, wsReadWindowTerm.id
    ARG dest, s32
    ARG window, s32
    ARG x, s32
    ARG y, s32
    ARG length, s32
    callCheckPerm window
    
    VAR index, s32
    mul index, y, termWidth
    add index, index, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    newAlloc dest, 0, length
    setErrJmp cleanUpAlloc
    wrtBuff dest[0]:s8, termBuff[index]:s8, length
    ret
    
    LBL cleanUpAlloc
    delAlloc dest
    VAR err, s8
    err err
    throw err
END

FUNC wrtWindowTerm, wsWrtWindowTerm.id
    ARG window, s32
    ARG x, s32
    ARG y, s32
    ARG text, s32
    callCheckPerm window
    
    VAR index, s32
    mul index, y, termWidth
    add index, index, x
    VAR termBuff, s32
    wrt termBuff, window[termBuff_OFFSET]:s32
    VAR size, s32
    allocSize size, text
    wrtBuff termBuff[index]:s8, text[0]:s8, size
    
    call acquireMutex
    VAR cond, s8
    equ cond, window, focusedWindow
    jmpZ skipDraw, cond
    newArgFrame wsWrtTerm.argsSize
    wrt wsWrtTerm.args.x, x
    wrt wsWrtTerm.args.y, y
    wrt wsWrtTerm.args.text, text
    callRemote termHandle, wrtTermIndex
    LBL skipDraw
    releaseMutex
END

APP_DATA
    LBL termNameStart
    DATA "wsTerm"
    LBL termNameEnd
    LBL testMessage1Start
    DATA "Milk\nEggs\nSugar\nButter\nFlour\nVanilla\nChocolate\nBaking powder\nSalt\nVegetable oil\nMustard"
    LBL testMessage1End
    LBL testMessage2Start
    DATA "Select an option:"
    LBL testMessage2End
    LBL testOption1Start
    DATA "Buy"
    LBL testOption1End
    LBL testOption2Start
    DATA "This is a really long option which requires horizontal scroll"
    LBL testOption2End
    LBL testOption3Start
    DATA "Sell"
    LBL testOption3End
END


